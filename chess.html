<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Learn Chess with AI Coach</title>
    <!-- Use the official chessboard.js CSS -->
    <link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(180deg, #ffffff 0%, #fafafa 100%);
            background-image: 
                linear-gradient(rgba(200, 200, 200, 0.08) 1px, transparent 1px),
                linear-gradient(90deg, rgba(200, 200, 200, 0.08) 1px, transparent 1px);
            background-size: 60px 60px;
            min-height: 100vh;
            color: #1a1a1a;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
            display: grid;
            grid-template-columns: 1fr 600px 1fr;
            gap: 30px;
            align-items: start;
            min-height: calc(100vh - 100px);
        }

        .header {
            grid-column: 1 / -1;
            text-align: center;
            color: #1a1a1a;
            margin-bottom: 20px;
        }

        .header h1 {
            font-size: 2rem;
            margin-bottom: 8px;
            font-weight: 700;
        }

        .header p {
            font-size: 1rem;
            color: #666;
        }

        .setup-panel {
            background: white;
            border-radius: 20px;
            padding: 20px;
            box-shadow: 
                0 1px 3px rgba(0, 0, 0, 0.04),
                0 1px 2px rgba(0, 0, 0, 0.02);
            border: 1px solid rgba(0, 0, 0, 0.06);
            max-height: calc(100vh - 160px);
            overflow-y: auto;
            position: sticky;
            top: 80px;
        }
        
        .setup-panel::-webkit-scrollbar {
            width: 6px;
        }
        
        .setup-panel::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }
        
        .setup-panel::-webkit-scrollbar-thumb {
            background: #ccc;
            border-radius: 3px;
        }
        
        .setup-panel::-webkit-scrollbar-thumb:hover {
            background: #999;
        }

        .coaching-panel {
            background: white;
            border-radius: 20px;
            padding: 20px;
            box-shadow: 
                0 1px 3px rgba(0, 0, 0, 0.04),
                0 1px 2px rgba(0, 0, 0, 0.02);
            border: 1px solid rgba(0, 0, 0, 0.06);
            display: flex;
            flex-direction: column;
            height: calc(100vh - 160px);
            min-height: 600px;
            max-height: 900px;
        }

        .board-container {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 
                0 1px 3px rgba(0, 0, 0, 0.04),
                0 1px 2px rgba(0, 0, 0, 0.02);
            border: 1px solid rgba(0, 0, 0, 0.06);
        }

        #myBoard {
            max-width: 100%;
            margin: 0 auto;
        }
        
        /* Removed all emoji-piece styling. We now use default images. */

        /* Make board not selectable */
        [class^="board-"] {
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
        }
        
        /* Style for the piece images from chessboard.js */
        #myBoard .piece-417db {
            cursor: grab;
        }
        
        h2 {
            color: #1a1a1a;
            margin-bottom: 20px;
            font-size: 1.5rem;
            font-weight: 700;
            border-bottom: 1px solid rgba(0, 0, 0, 0.06);
            padding-bottom: 10px;
        }

        .input-group {
            margin-bottom: 18px;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #555;
        }

        .input-group input,
        .input-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s;
        }

        .input-group input:focus,
        .input-group select:focus {
            outline: none;
            border-color: #667eea;
        }

        .color-selector {
            display: flex;
            gap: 15px;
            margin-top: 10px;
        }

        .color-option {
            flex: 1;
            padding: 15px;
            border: 3px solid #e0e0e0;
            border-radius: 10px;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s;
            font-weight: 600;
        }

        .color-option:hover {
            border-color: #1a1a1a;
            background: #f8f9fa;
        }

        .color-option.selected {
            border-color: #1a1a1a;
            background: #1a1a1a;
            color: white;
        }

        .btn {
            width: 100%;
            padding: 12px 20px;
            background: #1a1a1a;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease;
            margin-top: 10px;
        }

        .btn:hover:not(:disabled) {
            background: #333;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: #666;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #888;
        }

        .status-bar {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 8px;
            margin-top: 18px;
            border-left: 3px solid #1a1a1a;
        }

        .status-bar p {
            margin: 5px 0;
            font-size: 0.95rem;
        }

        .status-bar strong {
            color: #1a1a1a;
        }

        .coaching-chat {
            flex: 1;
            overflow-y: auto;
            border: none;
            border-radius: 0;
            padding: 0;
            background: transparent;
            margin-top: 15px;
            margin-bottom: 15px;
            min-height: 0; /* Important for flex scrolling */
        }

        .coaching-chat::-webkit-scrollbar {
            width: 8px;
        }

        .coaching-chat::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }

        .coaching-chat::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }

        .coaching-chat::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        .user-input-section {
            flex-shrink: 0;
            padding-top: 15px;
            border-top: 1px solid rgba(0, 0, 0, 0.08);
            background: transparent;
            border-radius: 0;
        }

        .message {
            margin-bottom: 20px;
            padding: 0;
            border-radius: 0;
            animation: fadeIn 0.3s;
            line-height: 1.7;
            width: 100%;
            border-bottom: 1px solid rgba(0, 0, 0, 0.08);
            padding-bottom: 20px;
        }
        
        .message:last-child {
            border-bottom: none;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .message.coach {
            background: transparent;
            border-left: none;
            box-shadow: none;
        }

        .message.player {
            background: transparent;
            border-left: none;
        }

        .message.system {
            background: transparent;
            border-left: none;
            color: #666;
            font-style: normal;
        }

        .message-header {
            font-weight: 600;
            margin-bottom: 12px;
            color: #1a1a1a;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.95rem;
        }

        .message-content {
            line-height: 1.8;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-size: 1rem;
            color: #1a1a1a;
            padding: 0;
            margin: 0;
        }

        .message-content strong {
            font-weight: 700;
            color: #1a1a1a;
        }

        /* Mini-board container for chessboard.js */
        .mini-board-img {
            width: 100%;
            max-width: 320px;
            height: auto;
            aspect-ratio: 1;
            margin: 15px 0;
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 6px;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.08);
        }

        /* Square highlight animation for mini-boards */
        @keyframes highlight-pulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 0.9; }
        }

        .square-highlight {
            animation: highlight-pulse 2s ease-in-out infinite;
        }

        .move-history {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 12px;
            margin-top: 18px;
            max-height: 250px;
            overflow-y: auto;
        }

        .move-history h3 {
            color: #1a1a1a;
            margin-bottom: 10px;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .move-item {
            padding: 8px;
            border-bottom: 1px solid #f0f0f0;
            font-family: 'Courier New', monospace;
            display: flex;
            justify-content: space-between;
        }

        .move-item:last-child {
            border-bottom: none;
        }

        .thinking {
            display: inline-block;
            padding: 8px 15px;
            background: #fff9e6;
            border-radius: 20px;
            font-size: 0.9rem;
            margin-top: 10px;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .game-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 20px;
        }

        .info-badge {
            display: inline-block;
            padding: 5px 12px;
            background: #1a1a1a;
            color: white;
            border-radius: 15px;
            font-size: 0.85rem;
            margin-right: 8px;
        }

        @media (max-width: 1400px) {
            .container {
                grid-template-columns: 1fr;
            }

            .header {
                grid-column: 1;
            }
        }

        /* Removed .highlight-square. It's no longer used. */

        .settings-toggle {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 8px;
            margin-top: 15px;
        }

        .settings-toggle label {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
        }

        .settings-toggle input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        /* Header navigation */
        .top-nav {
            padding: 0.75rem 3rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(20px) saturate(180%);
            position: sticky;
            top: 0;
            z-index: 100;
            border-bottom: 1px solid rgba(0, 0, 0, 0.06);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.02);
        }

        .logo {
            font-size: 1.1rem;
            font-weight: 600;
            color: #1a1a1a;
            text-decoration: none;
        }

        .back-btn {
            background-color: #1a1a1a;
            color: white;
            padding: 0.6rem 1.5rem;
            border-radius: 8px;
            text-decoration: none;
            font-size: 0.9rem;
            transition: background-color 0.2s ease;
        }

        .back-btn:hover {
            background-color: #333;
        }
    </style>
</head>
<body>
    <!-- Header Navigation -->
    <header class="top-nav">
        <a href="index.html" class="logo">AI Chess Coach</a>
        <a href="index.html" class="back-btn">‚Üê Back to Portfolio</a>
    </header>

    <div class="container">
        <div class="header">
            <h1>‚ôüÔ∏è Learn Chess with AI Coach</h1>
            <p>Improve your game with real-time Socratic coaching powered by Gemini or GPT-4o</p>
        </div>

        <!-- Left Panel: Setup & Controls -->
        <div class="setup-panel">
            <h2>Game Setup</h2>
            
            <div class="input-group">
                <label for="aiProvider">AI Model Provider</label>
                <select id="aiProvider">
                    <option value="gemini" selected>Gemini 2.5 Flash (Google)</option>
                    <option value="gpt4o">GPT-4o mini (OpenAI)</option>
                </select>
            </div>

            <div class="input-group" id="geminiKeyGroup">
                <label for="geminiApiKey">Gemini API Key</label>
                <input type="password" id="geminiApiKey" placeholder="Enter your Gemini API key">
                <small style="color: #666; margin-top: 5px; display: block;">Get your key from <a href="https://makersuite.google.com/app/apikey" target="_blank">Google AI Studio</a></small>
            </div>

            <div class="input-group" id="gpt4oKeyGroup" style="display: none;">
                <label for="gpt4oApiKey">OpenAI GPT-4o API Key</label>
                <input type="password" id="gpt4oApiKey" placeholder="Enter your OpenAI API key">
                <small style="color: #666; margin-top: 5px; display: block;">Get your key from <a href="https://platform.openai.com/api-keys" target="_blank">OpenAI</a></small>
            </div>

            <div class="input-group">
                <label>Choose Your Color</label>
                <div class="color-selector">
                    <div class="color-option selected" data-color="white">
                        ‚ö™ White
                    </div>
                    <div class="color-option" data-color="black">
                        ‚ö´ Black
                    </div>
                </div>
            </div>

            <div class="input-group">
                <label for="gameMode">Game Mode</label>
                <select id="gameMode">
                    <option value="coach">Coach Mode (Minimax Engine)</option>
                    <option value="llm">Play vs LLM</option>
                    
                </select>
                <small style="color: #666; margin-top: 5px; display: block;">Coach Mode: Minimax engine plays, LLM provides coaching only</small>
            </div>

            <div class="input-group">
                <label for="difficulty">AI Difficulty</label>
                <select id="difficulty">
                    <option value="beginner">Beginner (Elo ~800)</option>
                    <option value="intermediate" selected>Intermediate (Elo ~1200)</option>
                    <option value="advanced">Advanced (Elo ~1600)</option>
                    <option value="expert">Expert (Elo ~2000)</option>
                </select>
            </div>

            <div class="settings-toggle">
                <label>
                    <input type="checkbox" id="coachingEnabled" checked>
                    Enable AI Coaching
                </label>
            </div>

            <button class="btn" id="startGame">Start New Game</button>
            <button class="btn btn-secondary" id="resetGame" style="display:none;">Reset Game</button>

            <div class="status-bar">
                <p><strong>Status:</strong> <span id="gameStatus">Setup your game</span></p>
                <p><strong>Turn:</strong> <span id="turnIndicator">-</span></p>
                <p><strong>Material:</strong> <span id="materialCount">Equal</span></p>
            </div>

            <div class="move-history">
                <h3>üìú Move History</h3>
                <div id="moveList"></div>
            </div>
        </div>

        <!-- Center Panel: Chess Board -->
        <div class="board-container">
            <!-- This div is where chessboard.js will build the board -->
            <div id="myBoard"></div>
            <div class="game-controls">
                <button class="btn" id="undoMove" disabled>‚Ü∂ Undo Move</button>
            </div>
        </div>

        <!-- Right Panel: AI Coach -->
        <div class="coaching-panel">
            <div style="flex-shrink: 0;">
                <h2 style="margin-bottom: 6px;">AI Chess Coach</h2>
                <p style="color: #666; margin-bottom: 12px; font-size: 0.9rem;">Your personal chess mentor providing insights and teaching moments</p>
            </div>
            
            <div class="coaching-chat" id="coachingChat">
                <div class="message system">
                    <div class="message-content">
                        üëã Welcome! I'm your AI chess coach. Once you start the game, I'll observe your moves and provide guidance to help you improve. I'll teach you about openings, tactics, strategy, and help you think critically about each position.
                    </div>
                </div>
            </div>
            
            <div class="user-input-section">
                <label for="playerThoughts" style="display: block; margin-bottom: 8px; font-weight: 600; color: #555; font-size: 0.95rem;">üí¨ Ask a Question</label>
                <textarea 
                    id="playerThoughts" 
                    rows="2" 
                    placeholder="What are you thinking? Ask about openings, tactics, strategy..." 
                    style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 0.9rem; font-family: inherit; resize: none; margin-bottom: 8px;"></textarea>
                <div style="display: flex; gap: 8px;">
                    <button class="btn" id="shareThoughts" style="flex: 1; margin-top: 0; padding: 10px; font-size: 0.9rem;">Send</button>
                    <button class="btn btn-secondary" id="askCoach" style="flex: 1; margin-top: 0; padding: 10px; font-size: 0.9rem;">Ask Coach</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <!-- Use the official chessboard.js JS -->
    <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>
    <!-- Use the official chess.js JS (for game logic) - Using version 0.10.3 which works with script tags -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js" 
            onload="console.log('chess.js script tag loaded');" 
            onerror="console.error('Failed to load chess.js from cdnjs');"></script>
    
    <script>
        // Function to load chess.js from fallback CDN
        function loadChessFallback() {
            console.log('Trying fallback CDN for chess.js...');
            const script = document.createElement('script');
            script.src = 'https://unpkg.com/chess.js@0.10.3/chess.min.js';
            script.onerror = function() {
                console.error('Fallback CDN failed. Trying alternative...');
                // Try one more time with jsDelivr
                const script2 = document.createElement('script');
                script2.src = 'https://cdn.jsdelivr.net/npm/chess.js@0.10.3/chess.min.js';
                script2.onload = function() {
                    console.log('Checking Chess after jsDelivr load...', typeof Chess);
                    if (typeof Chess !== 'undefined') {
                        console.log('Chess.js loaded from jsDelivr with version 0.10.3');
                        initializeChessApp();
                    } else {
                        console.error('Chess.js loaded but Chess is still undefined');
                        alert('Error: Chess.js library loaded but Chess constructor is not available. Please refresh the page.');
                    }
                };
                script2.onerror = function() {
                    alert('Error: Chess.js library failed to load from all sources. Please check your internet connection and refresh the page.');
                };
                document.head.appendChild(script2);
            };
            script.onload = function() {
                console.log('Checking Chess after unpkg load...', typeof Chess);
                if (typeof Chess !== 'undefined') {
                    console.log('Chess.js loaded successfully from fallback CDN');
                    initializeChessApp();
                } else {
                    console.error('Chess.js loaded but Chess is still undefined');
                    // Try the jsDelivr fallback
                    script.onerror();
                }
            };
            document.head.appendChild(script);
        }
        
        // Wait for scripts to load and verify chess.js is available
        function waitForChess() {
            console.log('Checking for Chess.js...', typeof Chess);
            if (typeof Chess !== 'undefined') {
                console.log('Chess.js loaded successfully from main CDN');
                initializeChessApp();
            } else {
                // Check again after a longer delay to allow script to load
                setTimeout(function() {
                    console.log('Checking again for Chess.js...', typeof Chess);
                    if (typeof Chess !== 'undefined') {
                        console.log('Chess.js loaded successfully (delayed check)');
                        initializeChessApp();
                    } else {
                        console.error('Chess.js not found after waiting. Trying fallback...');
                        loadChessFallback();
                    }
                }, 1000); // Increased delay to 1 second
            }
        }
        
        // Start checking for Chess.js once DOM is ready
        // Give the script tag time to load first
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function() {
                setTimeout(waitForChess, 200);
            });
        } else {
            setTimeout(waitForChess, 200);
        }
        
        // Initialize the chess app once Chess.js is loaded
        function initializeChessApp() {
        
        // Game state
        let board = null;
        let game = null; // <-- FIX: Declare as null, will instantiate when DOM is ready
        let playerColor = 'white';
        let aiDifficulty = 'intermediate';
        let gameMode = 'llm'; // 'llm' or 'coach'
        let geminiApiKey = '';
        let gpt4oApiKey = '';
        let aiProvider = 'gemini';
        const GEMINI_MODEL = 'gemini-2.5-flash-preview-09-2025'; // Updated to valid model
        const GPT4O_MODEL = 'gpt-4o-mini';
        let coachingEnabled = true;
        let moveHistory = [];
        let gameStarted = false;
        let isAiThinking = false;
        let lastCoachingMove = 0; // Track when we last provided coaching
        let movesSinceCoaching = 0;

        // --- Start: Upgraded Minimax/Negamax AI Engine ---

        // Piece square tables for positional evaluation
        const pieceSquareTables = {
            'p': [
                [0, 0, 0, 0, 0, 0, 0, 0],
                [50, 50, 50, 50, 50, 50, 50, 50],
                [10, 10, 20, 30, 30, 20, 10, 10],
                [5, 5, 10, 25, 25, 10, 5, 5],
                [0, 0, 0, 20, 20, 0, 0, 0],
                [5, -5, -10, 0, 0, -10, -5, 5],
                [5, 10, 10, -20, -20, 10, 10, 5],
                [0, 0, 0, 0, 0, 0, 0, 0]
            ],
            'n': [
                [-50, -40, -30, -30, -30, -30, -40, -50],
                [-40, -20, 0, 0, 0, 0, -20, -40],
                [-30, 0, 10, 15, 15, 10, 0, -30],
                [-30, 5, 15, 20, 20, 15, 5, -30],
                [-30, 0, 15, 20, 20, 15, 0, -30],
                [-30, 5, 10, 15, 15, 10, 5, -30],
                [-40, -20, 0, 5, 5, 0, -20, -40],
                [-50, -40, -30, -30, -30, -30, -40, -50]
            ],
            'b': [
                [-20, -10, -10, -10, -10, -10, -10, -20],
                [-10, 0, 0, 0, 0, 0, 0, -10],
                [-10, 0, 5, 10, 10, 5, 0, -10],
                [-10, 5, 5, 10, 10, 5, 5, -10],
                [-10, 0, 10, 10, 10, 10, 0, -10],
                [-10, 10, 10, 10, 10, 10, 10, -10],
                [-10, 5, 0, 0, 0, 0, 5, -10],
                [-20, -10, -10, -10, -10, -10, -10, -20]
            ],
            'r': [
                [0, 0, 0, 0, 0, 0, 0, 0],
                [5, 10, 10, 10, 10, 10, 10, 5],
                [-5, 0, 0, 0, 0, 0, 0, -5],
                [-5, 0, 0, 0, 0, 0, 0, -5],
                [-5, 0, 0, 0, 0, 0, 0, -5],
                [-5, 0, 0, 0, 0, 0, 0, -5],
                [-5, 0, 0, 0, 0, 0, 0, -5],
                [0, 0, 0, 5, 5, 0, 0, 0]
            ],
            'q': [
                [-20, -10, -10, -5, -5, -10, -10, -20],
                [-10, 0, 0, 0, 0, 0, 0, -10],
                [-10, 0, 5, 5, 5, 5, 0, -10],
                [-5, 0, 5, 5, 5, 5, 0, -5],
                [0, 0, 5, 5, 5, 5, 0, -5],
                [-10, 5, 5, 5, 5, 5, 0, -10],
                [-10, 0, 5, 0, 0, 0, 0, -10],
                [-20, -10, -10, -5, -5, -10, -10, -20]
            ],
            'k': [
                [-30, -40, -40, -50, -50, -40, -40, -30],
                [-30, -40, -40, -50, -50, -40, -40, -30],
                [-30, -40, -40, -50, -50, -40, -40, -30],
                [-30, -40, -40, -50, -50, -40, -40, -30],
                [-20, -30, -30, -40, -40, -30, -30, -20],
                [-10, -20, -20, -20, -20, -20, -20, -10],
                [20, 20, 0, 0, 0, 0, 20, 20],
                [20, 30, 10, 0, 0, 10, 30, 20]
            ]
        };

        // Base piece values
        const pieceValues = { 'p': 100, 'n': 320, 'b': 330, 'r': 500, 'q': 900, 'k': 20000 };

        /**
         * This is a standard evaluation function for a negamax algorithm.
         * It returns the score relative to the *current player to move*.
         */
        function evaluate(state) {
            if (state.in_checkmate()) {
                return -Infinity; // Current player is checkmated
            }
            if (state.in_draw() || state.in_stalemate()) {
                return 0;
            }

            let score = 0;
            const board = state.board();
            const turn = state.turn(); // 'w' or 'b'

            for (let r = 0; r < 8; r++) {
                for (let f = 0; f < 8; f++) {
                    const piece = board[r][f];
                    if (piece) {
                        const value = pieceValues[piece.type];
                        let positionalScore = 0;

                        if (piece.color === 'w') {
                            positionalScore = pieceSquareTables[piece.type][r][f];
                        } else {
                            // Flip row for black
                            positionalScore = pieceSquareTables[piece.type][7 - r][f];
                        }

                        if (piece.color === turn) {
                            score += (value + positionalScore);
                        } else {
                            score -= (value + positionalScore);
                        }
                    }
                }
            }

            // Add mobility score (simple version)
            const moves = state.moves();
            score += moves.length * 5; // 5 points per legal move

            return score;
        }

        // Transposition table for memoization
        let transpositionTable = {};

        /**
         * Standard Negamax algorithm with Alpha-Beta Pruning and Transposition Table.
         */
        function negamax(state, depth, alpha, beta) {
            const fen = state.fen();

            // Transposition table lookup
            if (transpositionTable[fen] && transpositionTable[fen].depth >= depth) {
                return transpositionTable[fen].score;
            }

            if (depth === 0 || state.game_over()) {
                // We want the score from the perspective of the player *whose turn it is*
                return evaluate(state);
            }

            let maxScore = -Infinity;
            const moves = state.moves({ verbose: true });
            
            // Simple move ordering: captures first
            moves.sort((a, b) => (b.flags.includes('c') ? 1 : 0) - (a.flags.includes('c') ? 1 : 0));

            for (const move of moves) {
                state.move(move);
                const score = -negamax(state, depth - 1, -beta, -alpha);
                state.undo();

                if (score > maxScore) {
                    maxScore = score;
                }
                if (score > alpha) {
                    alpha = score;
                }
                if (alpha >= beta) {
                    break; // Beta cut-off
                }
            }
            
            // Store in transposition table
            transpositionTable[fen] = { depth: depth, score: maxScore };
            
            return maxScore;
        }

        /**
         * Root function to find the best move using Negamax.
         */
        function getMinimaxMove(state, side, depth) {
            // Clear transposition table for each new move
            transpositionTable = {}; 
            
            const moves = state.moves({ verbose: true });
            if (moves.length === 0) return null;

            let bestScore = -Infinity;
            let bestMove = moves[0];
            
            // Simple move ordering: captures first
            moves.sort((a, b) => (b.flags.includes('c') ? 1 : 0) - (a.flags.includes('c') ? 1 : 0));

            for (const move of moves) {
                state.move(move);
                // The score returned by negamax is from the *next* player's perspective.
                // So, we negate it to get the score from the *current* player's perspective.
                const score = -negamax(state, depth - 1, -Infinity, Infinity);
                state.undo();

                if (score > bestScore) {
                    bestScore = score;
                    bestMove = move;
                }
            }
            return bestMove;
        }


        function getMinimaxDepth() {
            // Adjust depth based on difficulty
            const depthMap = {
                'beginner': 2,
                'intermediate': 3,
                'advanced': 4,
                'expert': 5
            };
            return depthMap[aiDifficulty] || 3;
        }

        // --- End: Upgraded Minimax/Negamax AI Engine ---


        // Initialize
        $(document).ready(function() {
            // Double-check that Chess is available before initializing
            if (typeof Chess === 'undefined') {
                console.error('Chess is not defined when trying to initialize!');
                alert('Error: Chess.js library is not loaded. Please refresh the page.');
                return;
            }
            
            try {
                game = new Chess(); // <-- FIX: Instantiate here to ensure chess.js is loaded
                initializeBoard();
                setupEventListeners();
                console.log('Chess board initialized successfully');
            } catch (error) {
                console.error('Error initializing chess board:', error);
                alert('Error initializing chess board. Please refresh the page.');
            }
        });


        // Removed pieceEmojis map
        // Removed convertImagesToEmojis function
        // Removed setupBoardObserver function

        function initializeBoard() {
            // Use local chess piece images from chess_images directory
            const pieceTheme = 'chess_images/chesspieces/wikipedia/{piece}.png';
            
            const config = {
                draggable: true,
                position: 'start',
                pieceTheme: pieceTheme, // Use real images
                onDragStart: onDragStart,
                onDrop: onDrop,
                onSnapEnd: onSnapEnd
                // Removed the 'onChange' handler, it's not needed
            };
            board = Chessboard('myBoard', config);
            $(window).resize(board.resize);
            
            // No emoji conversion needed anymore
        }

        function setupEventListeners() {
            aiProvider = $('#aiProvider').val();
            updateProviderUI();

            $('#aiProvider').change(function() {
                aiProvider = $(this).val();
                updateProviderUI();
            });

            // Color selection
            $('.color-option').click(function() {
                $('.color-option').removeClass('selected');
                $(this).addClass('selected');
                playerColor = $(this).data('color');
            });

            // Start game
            $('#startGame').click(startNewGame);
            
            // Reset game
            $('#resetGame').click(resetGame);

            // Undo move
            $('#undoMove').click(undoLastMove);

            // Ask coach
            $('#askCoach').click(askCoachForAdvice);

            // Send message
            $('#shareThoughts').click(sendPlayerMessage);

            // Also allow Enter key to send message
            $('#playerThoughts').keydown(function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendPlayerMessage();
                }
            });

            // Difficulty change
            $('#difficulty').change(function() {
                aiDifficulty = $(this).val();
            });

            // Game mode change
            $('#gameMode').change(function() {
                gameMode = $(this).val();
            });

            // Coaching toggle
            $('#coachingEnabled').change(function() {
                coachingEnabled = $(this).is(':checked');
            });
        }

        function updateProviderUI() {
            const selectedProvider = $('#aiProvider').val();
            $('#geminiKeyGroup').toggle(selectedProvider === 'gemini');
            $('#gpt4oKeyGroup').toggle(selectedProvider === 'gpt4o');
        }

        function startNewGame() {
            aiProvider = $('#aiProvider').val();
            gameMode = $('#gameMode').val();
            geminiApiKey = $('#geminiApiKey').val().trim();
            gpt4oApiKey = $('#gpt4oApiKey').val().trim();

            // Only require API keys if using LLM mode or if coaching is enabled
            if (gameMode === 'llm' || coachingEnabled) {
                if (aiProvider === 'gemini' && !geminiApiKey) {
                    // Use new message system instead of alert
                    addCoachMessage('system', 'Please enter your Gemini API key to use AI features.');
                    return;
                }

                if (aiProvider === 'gpt4o' && !gpt4oApiKey) {
                    // Use new message system instead of alert
                    addCoachMessage('system', 'Please enter your OpenAI GPT-4o API key to use AI features.');
                    return;
                }
            }

            game = new Chess(); // Re-initialize game on new game
            moveHistory = [];
            gameStarted = true;
            lastCoachingMove = 0;
            movesSinceCoaching = 0;
            
            board.position('start');
            
            if (playerColor === 'black') {
                board.orientation('black');
                setTimeout(() => {
                    makeAiMove();
                }, 500);
            } else {
                board.orientation('white');
            }

            $('#startGame').hide();
            $('#resetGame').show();
            $('#undoMove').prop('disabled', false);
            
            updateStatus();
            updateMoveHistory();
            
            if (coachingEnabled) {
                setTimeout(() => {
                    provideOpeningAdvice();
                }, 1000);
            }
        }

        function resetGame() {
            // Removed confirm() as it's blocked
            game = new Chess(); // Re-initialize game on reset
            board.position('start');
            moveHistory = [];
            gameStarted = false;
            lastCoachingMove = 0;
            movesSinceCoaching = 0;
            
            // Clear AI reasoning
            lastAiReasoning = null;
            lastAiMove = null;
            $('.ai-thinking-btn').remove();
            
            $('#startGame').show();
            $('#resetGame').hide();
            $('#undoMove').prop('disabled', true);
            
            updateStatus();
            updateMoveHistory();
            $('#coachingChat').html(`
                <div class="message system">
                    <div class="message-content">
                        Game reset. Start a new game when ready!
                    </div>
                </div>
            `);
        }

        function onDragStart(source, piece, position, orientation) {
            if (!gameStarted) return false;
            if (game.game_over()) return false;
            if (isAiThinking) return false;
            
            // Only allow player to move their own pieces
            if ((playerColor === 'white' && piece.search(/^b/) !== -1) ||
                (playerColor === 'black' && piece.search(/^w/) !== -1)) {
                return false;
            }
            
            // Only allow moves on player's turn
            if ((game.turn() === 'w' && playerColor === 'black') ||
                (game.turn() === 'b' && playerColor === 'white')) {
                return false;
            }
        }

        function onDrop(source, target) {
            let move = null;
            try {
                // Check if move is legal
                move = game.move({
                    from: source,
                    to: target,
                    promotion: 'q' // Always promote to queen for simplicity
                });
            } catch (e) {
                // This can happen with chess.js v1+ if the move is invalid
                console.warn("Invalid move attempted:", e.message);
                return 'snapback';
            }

            // Illegal move
            if (move === null) return 'snapback';

            // Legal move made
            moveHistory.push({
                move: move,
                fen: game.fen(),
                player: playerColor
            });

            updateStatus();
            updateMoveHistory();

            // Make AI move (coaching happens after AI responds)
            if (!game.game_over()) {
                setTimeout(() => makeAiMove(), 500); // Reduced delay
            }
        }

        function onSnapEnd() {
            // The board state is already updated by game.move()
            // We just need to ensure the board UI reflects the game logic's FEN
            board.position(game.fen());
            // No emoji conversion needed
        }

        // Store AI reasoning for the last move
        let lastAiReasoning = null;
        let lastAiMove = null;

        async function makeAiMove() {
            if (game.game_over()) return;
            
            isAiThinking = true;
            // Removed "AI is thinking" message
            
            try {
                let moveObject;
                let moveToMake;
                
                // Use minimax if in coach mode, otherwise use LLM
                if (gameMode === 'coach') {
                    // Add a small delay to show the engine is "thinking"
                    await new Promise(resolve => setTimeout(resolve, 100)); // Shorter delay
                    
                    const depth = getMinimaxDepth();
                    const currentSide = game.turn();
                    moveToMake = getMinimaxMove(game, currentSide, depth);
                    
                    if (!moveToMake) {
                        isAiThinking = false;
                        return;
                    }
                    
                    // Execute the move
                    moveObject = game.move(moveToMake);
                } else {
                    // LLM mode
                    moveToMake = await getAiMove();
                    
                    if (moveToMake) {
                        // Execute the move
                        moveObject = game.move(moveToMake);
                    } else {
                        isAiThinking = false;
                        return;
                    }
                }
                
                if (!moveObject) {
                    console.error('Invalid move attempted by AI');
                    // Try a random move as a fallback
                    const moves = game.moves({ verbose: true });
                    if(moves.length > 0) {
                        moveObject = game.move(moves[Math.floor(Math.random() * moves.length)]);
                    } else {
                        isAiThinking = false;
                        return;
                    }
                }
                
                board.position(game.fen());
                
                moveHistory.push({
                    move: moveObject,
                    fen: game.fen(),
                    player: playerColor === 'white' ? 'black' : 'white'
                });
                
                // Store AI move
                lastAiMove = moveObject;
                
                // Get AI reasoning for the move (only if coaching is enabled and we have API key)
                if (coachingEnabled && (gameMode === 'llm' || geminiApiKey || gpt4oApiKey)) {
                    try {
                        const reasoning = await getAiReasoning(moveObject);
                        lastAiReasoning = reasoning;
                        
                        // Add button to see AI thinking (only for LLM mode)
                        if (gameMode === 'llm') {
                            addAiThinkingButton();
                        }
                    } catch (error) {
                        console.error('Error getting AI reasoning:', error);
                        lastAiReasoning = null;
                    }
                } else {
                    lastAiReasoning = null;
                }
                
                updateStatus();
                updateMoveHistory();
                
                // Now check if coach should provide feedback after the complete exchange
                if (coachingEnabled && !game.game_over() && (gameMode === 'llm' || geminiApiKey || gpt4oApiKey)) {
                    setTimeout(() => analyzePlayerMove(moveObject), 500);
                }
            } catch (error) {
                console.error('AI move error:', error);
                if (gameMode === 'llm') {
                    addCoachMessage('system', '‚ö†Ô∏è Error making AI move. Please try again.');
                } else {
                    addCoachMessage('system', '‚ö†Ô∏è Error making minimax move.');
                }
            }
            
            isAiThinking = false;
        }

        async function getAiMove() {
            const legalMoves = game.moves({ verbose: true });
            if (legalMoves.length === 0) return null;

            const currentFen = game.fen();
            const moveHistoryText = moveHistory.slice(-10).map(m => m.move.san).join(' ');

            // Prompt adjusted for new chess.js version
            const prompt = `You are a world class chess player engine playing at extreme difficulty level. Think like a grandmaster and play the best possible move.
Current position (FEN): ${currentFen}
Recent moves: ${moveHistoryText}
Legal moves (in SAN format): ${legalMoves.map(m => m.san).join(', ')}

Respond with ONLY your chosen move in Standard Algebraic Notation (e.g., "e4", "Nf3", "O-O"). Pick ONE move.`;

            try {
                const response = await callAiAPI(prompt, 'ai-player');
                const moveText = response.trim().replace(/['".]/g, ''); // Clean up response
                
                // Try to find matching move
                let matchingMove = legalMoves.find(m => m.san === moveText);

                if (!matchingMove) {
                    // Try to find by coordinate notation (e.g., e2e4)
                    matchingMove = legalMoves.find(m => m.from + m.to === moveText.toLowerCase());
                }
                
                if (matchingMove) {
                    return matchingMove;
                }
                
                // Fallback: AI gave a weird response, pick a random move
                console.warn(`AI returned non-legal move: "${moveText}". Picking random move.`);
                return legalMoves[Math.floor(Math.random() * legalMoves.length)];
                
            } catch (error) {
                console.error('Error getting AI move:', error);
                // Fallback: random legal move
                return legalMoves[Math.floor(Math.random() * legalMoves.length)];
            }
        }

        async function getAiReasoning(move) {
            const currentFen = game.fen();
            const moveHistoryText = moveHistory.slice(-10).map(m => m.move.san).join(' ');
            const moveNotation = move.san;

            const prompt = `You are a chess AI explaining your move to a learning player. You just played ${moveNotation}.

Current position (FEN): ${currentFen}
Recent moves: ${moveHistoryText}
Your move: ${moveNotation}
Difficulty: ${aiDifficulty}

Explain why you made this move in 2-3 sentences:
1. What was your strategic or tactical goal?
2. What threats or opportunities were you responding to?
3. What squares or pieces were you trying to control?

Be educational and help the player understand opponent thinking. Keep it concise and clear.`;

            try {
                const reasoning = await callAiAPI(prompt, 'coach');
                return reasoning;
            } catch (error) {
                console.error('Error getting AI reasoning:', error);
                return null;
            }
        }

        function addAiThinkingButton() {
            // Remove any existing AI thinking button
            $('.ai-thinking-btn').remove();
            
            if (!lastAiReasoning || !lastAiMove) return;
            
            const button = $('<button>')
                .addClass('btn btn-secondary ai-thinking-btn')
                .css({
                    'margin-top': '10px',
                    'width': '100%',
                    'font-size': '0.9rem'
                })
                .html('üß† See Why AI Played ' + lastAiMove.san)
                .click(function() {
                    showAiThinking();
                });
            
            // Add button after the last message in coaching chat
            $('#coachingChat').append(button);
            $('#coachingChat').scrollTop($('#coachingChat')[0].scrollHeight);
        }

        function showAiThinking() {
            if (!lastAiReasoning || !lastAiMove) return;
            
            const currentFen = game.fen();
            const message = `AI Move: ${lastAiMove.san}\n\n${lastAiReasoning}`;
            
            // Extract mentioned squares for highlighting
            const squarePattern = /\b[a-h][1-8]\b/g;
            const mentionedSquares = lastAiReasoning.match(squarePattern) || [];
            
            addCoachMessage('coach', message, currentFen, mentionedSquares);
            
            // Remove the button after showing
            $('.ai-thinking-btn').remove();
        }

        async function sendPlayerMessage() {
            const message = $('#playerThoughts').val().trim();
            
            if (!message) {
                return;
            }
            
            if (!gameStarted) {
                addCoachMessage('system', 'Start a game first before asking questions!');
                return;
            }
            
            // Add player message to chat
            addCoachMessage('player', message);
            
            // Clear input
            $('#playerThoughts').val('');
            
            // Get AI coach response
            const currentFen = game.fen();
            const recentMoves = moveHistory.slice(-8).map(m => m.move.san).join(' ');
            const moveNumber = Math.floor(moveHistory.length / 2) + 1;
            
            const prompt = `You are a helpful chess coach. The student just sent you a message: "${message}"

Current position (FEN): ${currentFen}
Recent moves: ${recentMoves}
Move number: ${moveNumber}
Player color: ${playerColor}
Player's turn: ${(game.turn() === 'w' && playerColor === 'white') || (game.turn() === 'b' && playerColor === 'black') ? 'Yes' : 'No'}

Respond helpfully to their message. Provide guidance, answer their question, or discuss the position. Keep response to 3-4 sentences. Be encouraging and educational.
**Important**: If you mention key squares, list them in your text (e.g., "focus on controlling e4 and d5").

**CRITICAL FOR OPENING DEMONSTRATIONS**: If the student is asking about a specific opening (e.g., "show me the Queen's Gambit" or "what is the Sicilian Defense?") or how to play an opening, you MUST provide the move sequence so they can see the moves animated.

YOU MUST include the moves in this exact format at the end of your response: [MOVES: d4 d5 c4]

For Queen's Gambit specifically, your response MUST end with: [MOVES: d4 d5 c4]

Other examples:
- Sicilian Defense: [MOVES: e4 c5]
- Italian Game: [MOVES: e4 e5 Nf3 Nc6 Bc4]
- French Defense: [MOVES: e4 e6]

If you are NOT discussing an opening, omit the [MOVES: ...] tag.`;

            try {
                const response = await callAiAPI(prompt, 'coach');
                
                console.log('AI Response:', response); // Debug logging
                
                // Extract move sequence if present - try multiple patterns
                let movesMatch = response.match(/\[MOVES:\s*([^\]]+)\]/i);
                if (!movesMatch) {
                    // Try without brackets
                    movesMatch = response.match(/MOVES:\s*([a-h1-8NBRQKO\-]+(?:\s+[a-h1-8NBRQKO\-]+)+)/i);
                }
                if (!movesMatch) {
                    // Try to detect common opening patterns in text
                    const queenGambitPattern = /(?:queen'?s gambit|queens gambit).*?(?:1\.\s*d4|d4).*?(?:2\.\s*d5|d5).*?(?:3\.\s*c4|c4)/i;
                    if (queenGambitPattern.test(response.toLowerCase())) {
                        movesMatch = ['', 'd4 d5 c4'];
                    }
                }
                
                let moveSequence = null;
                let cleanResponse = response;
                
                if (movesMatch && movesMatch[1]) {
                    const movesString = movesMatch[1].trim();
                    moveSequence = movesString.split(/\s+/).filter(m => m.length > 0 && !m.match(/^\d+\.$/));
                    console.log('Extracted move sequence:', moveSequence); // Debug logging
                    // Remove the moves marker from the message
                    cleanResponse = response.replace(/\[MOVES:[^\]]+\]/gi, '').trim();
                }
                
                // Extract teaching FEN if present
                const teachingFenMatch = cleanResponse.match(/\[TEACHING_FEN:\s*([^\]]+)\]/i);
                let teachingFen = null;
                
                if (teachingFenMatch) {
                    teachingFen = teachingFenMatch[1].trim();
                    // Remove the teaching FEN marker from the message
                    cleanResponse = cleanResponse.replace(/\[TEACHING_FEN:[^\]]+\]/gi, '').trim();
                }
                
                // Use teaching FEN if provided and no move sequence, otherwise use current FEN
                const fenToUse = (moveSequence && moveSequence.length > 0 ? null : (teachingFen || currentFen));
                
                // Extract mentioned squares for highlighting
                const squarePattern = /\b[a-h][1-8]\b/g;
                const mentionedSquares = cleanResponse.match(squarePattern) || [];
                
                console.log('Calling addCoachMessage with moveSequence:', moveSequence); // Debug logging
                addCoachMessage('coach', cleanResponse, fenToUse, mentionedSquares, moveSequence);
            } catch (error) {
                console.error('Error getting coach response:', error);
                addCoachMessage('system', '‚ö†Ô∏è Error getting coach response. Please check your API key.');
            }
        }

        async function analyzePlayerMove(move) {
            movesSinceCoaching++;
            
            // Only analyze after BOTH players have moved (complete turn pair)
            if (moveHistory.length % 2 !== 0) return;
            
            const currentFen = game.fen();
            const moveNumber = Math.floor(moveHistory.length / 2);
            const lastTwoMoves = moveHistory.slice(-2).map(m => m.move.san);
            const playerLastMove = lastTwoMoves[0];
            const aiLastMove = lastTwoMoves[1];
            const recentMoves = moveHistory.slice(-6).map(m => m.move.san).join(' ');

            // Strategic coaching moments
            const isCheckOrCheckmate = game.in_check() || game.in_checkmate();
            const isOpeningPhase = moveNumber <= 5;
            const isKeyMoment = movesSinceCoaching >= 4; // Every 4 complete turns
            const isCriticalPosition = game.in_check() || game.in_checkmate() || game.in_stalemate();
            
            const shouldCoach = isCheckOrCheckmate || 
                                (isOpeningPhase && moveNumber % 2 === 0) || // Every 2 turns in opening
                                (isKeyMoment && !isOpeningPhase) || // Every 4 turns mid/endgame
                                isCriticalPosition;

            if (!shouldCoach) return;

            // Reset counter
            movesSinceCoaching = 0;
            lastCoachingMove = moveHistory.length;

            const gamePhase = moveNumber <= 5 ? 'Opening' : moveNumber <= 20 ? 'Middlegame' : 'Endgame';

            const prompt = `You are a chess coach observing a game. Analyze the last exchange of moves and provide strategic guidance.

Current position (FEN): ${currentFen}
Move number: ${moveNumber}
Your student (${playerColor}) played: ${playerLastMove}
Opponent responded: ${aiLastMove}
Recent moves: ${recentMoves}
Game phase: ${gamePhase}
Position status: ${game.in_check() ? 'Check!' : game.in_checkmate() ? 'Checkmate!' : game.in_stalemate() ? 'Stalemate' : 'Normal'}

As a Socratic coach:
1. Analyze the last exchange (both moves together)
2. Ask thought-provoking questions about the position
3. Identify key squares, threats, or opportunities
4. Teach relevant chess concepts (tactics, strategy, openings)
5. **Important**: In your response, list 1-2 specific key squares (like "e5", "d4") that are important
6. Keep response to 3-4 sentences

Be encouraging but insightful. Focus on teaching, not just describing.`;

            try {
                const coaching = await callAiAPI(prompt, 'coach');
                
                // Extract mentioned squares from coaching for highlighting
                const squarePattern = /\b[a-h][1-8]\b/g;
                const mentionedSquares = coaching.match(squarePattern) || [];
                
                addCoachMessage('coach', coaching, currentFen, mentionedSquares);
            } catch (error) {
                console.error('Error getting coaching:', error);
            }
        }

        async function provideOpeningAdvice() {
            const prompt = `You are a chess coach at the start of a game. The player is playing as ${playerColor}. 
Provide brief (2-3 sentences) encouraging advice about opening principles:
- Control the center (e.g., e4, d4, e5, d5)
- Develop pieces
- King safety
- Don't move the same piece twice

Be warm and encouraging.`;

            try {
                const advice = await callAiAPI(prompt, 'coach');
                addCoachMessage('coach', advice);
            } catch (error) {
                console.error('Error getting opening advice:', error);
            }
        }

        async function askCoachForAdvice() {
            if (!gameStarted) {
                addCoachMessage('system', 'Start a game first before asking for advice!');
                return;
            }

            const currentFen = game.fen();
            const recentMoves = moveHistory.slice(-8).map(m => m.move.san).join(' ');
            const moveNumber = Math.floor(moveHistory.length / 2) + 1;

            addCoachMessage('player', 'I could use some advice on this position. What should I be thinking about?');

            const prompt = `You are an expert and encouraging chess coach. Your primary goal is not just to give the next move, but to teach the student underlying chess concepts so they can improve long-term.

Use the provided game data to give a comprehensive, educational mini-lesson. Keep the responses between 200-250 characters.

Game Data:

Current position (FEN): ${currentFen}

Recent moves: ${recentMoves}

Move number: ${moveNumber}

Player color: ${playerColor}

Player's turn: ${(game.turn() === 'w' && playerColor === 'white') || (game.turn() === 'b' && playerColor === 'black') ? 'Yes' : 'No'}

Your Guidance:
1. üéì The Big Picture: What setup is this?

Based on the ${recentMoves} and ${moveNumber}, identify any named concepts.

If it's an opening: Does this resemble a specific named opening (e.g., "This is a setup from the Queen's Gambit")? Briefly explain the main goals or typical plans for ${playerColor} in this system.

If it's a middlegame/endgame: Identify any key pawn structures (e.g., "isolated queen's pawn," "passed pawn"), tactical themes (e.g., "potential pin," "back-rank weakness"), or positional features (e.g., "bishop pair," "open c-file").

2. üéØ Current Board Analysis: What matters right now?

Key Features: What are the 1-2 most important, immediate features of this specific position (e.g., "Your king is still in the center," "Their knight on f6 is very strong")?

Critical Squares: Name 1-2 specific squares that are vital to control (e.g., "e5", "d4").

3. üí° Actionable Advice: What are some good ideas?

Candidate Moves: Suggest 1-2 good candidate moves to consider.

The "Why": For each move, explain the strategic idea behind it (e.g., "This move develops a piece while also challenging their control of the center," or "This move creates an escape square for your king").

4. ü§î Food for Thought: A question to ask yourself.

Conclude with one guiding question to help the student think critically (e.g., "How can you improve the coordination of your rooks?" or "If you make that trade, whose pawn structure will be better?").

**CRITICAL FOR OPENING DEMONSTRATIONS**: If you are teaching about a specific opening (e.g., Queen's Gambit, Sicilian Defense, etc.), you MUST provide the move sequence so the student can see the moves animated.

YOU MUST include the moves in this exact format at the end of your response: [MOVES: d4 d5 c4]

For Queen's Gambit specifically, your response MUST end with: [MOVES: d4 d5 c4]

Other examples:
- Sicilian Defense: [MOVES: e4 c5]
- Italian Game: [MOVES: e4 e5 Nf3 Nc6 Bc4]
- French Defense: [MOVES: e4 e6]

If you are NOT discussing an opening, omit the [MOVES: ...] tag.`;

            try {
                const advice = await callAiAPI(prompt, 'coach');
                
                console.log('AI Advice Response:', advice); // Debug logging
                
                // Extract move sequence if present - try multiple patterns
                let movesMatch = advice.match(/\[MOVES:\s*([^\]]+)\]/i);
                if (!movesMatch) {
                    // Try without brackets
                    movesMatch = advice.match(/MOVES:\s*([a-h1-8NBRQKO\-]+(?:\s+[a-h1-8NBRQKO\-]+)+)/i);
                }
                if (!movesMatch) {
                    // Try to detect common opening patterns in text
                    const queenGambitPattern = /(?:queen'?s gambit|queens gambit).*?(?:1\.\s*d4|d4).*?(?:2\.\s*d5|d5).*?(?:3\.\s*c4|c4)/i;
                    if (queenGambitPattern.test(advice.toLowerCase())) {
                        movesMatch = ['', 'd4 d5 c4'];
                    }
                }
                
                let moveSequence = null;
                let cleanAdvice = advice;
                
                if (movesMatch && movesMatch[1]) {
                    const movesString = movesMatch[1].trim();
                    moveSequence = movesString.split(/\s+/).filter(m => m.length > 0 && !m.match(/^\d+\.$/));
                    console.log('Extracted move sequence:', moveSequence); // Debug logging
                    // Remove the moves marker from the message
                    cleanAdvice = advice.replace(/\[MOVES:[^\]]+\]/gi, '').trim();
                }
                
                // Extract teaching FEN if present
                const teachingFenMatch = cleanAdvice.match(/\[TEACHING_FEN:\s*([^\]]+)\]/i);
                let teachingFen = null;
                
                if (teachingFenMatch) {
                    teachingFen = teachingFenMatch[1].trim();
                    // Remove the teaching FEN marker from the message
                    cleanAdvice = cleanAdvice.replace(/\[TEACHING_FEN:[^\]]+\]/gi, '').trim();
                }
                
                // Use teaching FEN if provided and no move sequence, otherwise use current FEN
                const fenToUse = (moveSequence && moveSequence.length > 0 ? null : (teachingFen || currentFen));
                
                // Extract mentioned squares for highlighting
                const squarePattern = /\b[a-h][1-8]\b/g;
                const mentionedSquares = cleanAdvice.match(squarePattern) || [];
                
                console.log('Calling addCoachMessage with moveSequence:', moveSequence); // Debug logging
                addCoachMessage('coach', cleanAdvice, fenToUse, mentionedSquares, moveSequence);
            } catch (error) {
                console.error('Error getting advice:', error);
                addCoachMessage('system', '‚ö†Ô∏è Error getting coaching advice. Please check your API key.');
            }
        }

        async function callAiAPI(prompt, context) {
            const temperature = context === 'coach' ? 0.8 : 0.7;
            const maxTokens = context === 'ai-player' ? 50 : 800; // Increased for coach to allow teaching FEN

            if (aiProvider === 'gpt4o') {
                if (!gpt4oApiKey) {
                    throw new Error('OpenAI API key is missing.');
                }

                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${gpt4oApiKey}`,
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        model: GPT4O_MODEL,
                        temperature,
                        max_tokens: maxTokens,
                        messages: [
                            {
                                role: 'user',
                                content: prompt
                            }
                        ]
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    console.error('OpenAI API Error:', errorData);
                    throw new Error(`OpenAI API call failed: ${response.status}`);
                }

                const data = await response.json();
                const message = data.choices?.[0]?.message?.content;
                if (!message) {
                    throw new Error('OpenAI API returned an empty response.');
                }

                return message.trim();
            }

            // Default to Gemini
            if (!geminiApiKey) {
                throw new Error('Gemini API key is missing.');
            }

            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent`, {
                method: 'POST',
                headers: {
                    'x-goog-api-key': geminiApiKey,
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    contents: [{
                        parts: [{
                            text: prompt
                        }]
                    }],
                    generationConfig: {
                        temperature,
                        maxOutputTokens: maxTokens,
                    }
                })
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                console.error('Gemini API Error:', errorData);
                throw new Error(`Gemini API call failed: ${response.status}`);
            }

            const data = await response.json();
            const text = data.candidates?.[0]?.content?.parts?.[0]?.text;
            if (!text) {
                // Check for safety blocks
                if(data.candidates?.[0]?.finishReason === 'SAFETY') {
                    console.warn('Gemini API blocked response due to safety settings.');
                    return "My response was blocked by safety filters. Let's try a different topic.";
                }
                throw new Error('Gemini API returned an empty response.');
            }

            return text.trim();
        }

        /**
         * Animates a sequence of moves on a mini-board
         */
        function animateMovesOnMiniBoard(boardInstance, moves, startFen = 'start', highlightSquares = [], boardId) {
            console.log('animateMovesOnMiniBoard called with:', { boardInstance, moves, startFen, highlightSquares, boardId });
            if (!boardInstance) {
                console.error('No board instance provided');
                return;
            }
            
            // Normalize startFen - if it's 'start', use undefined to get default starting position
            const normalizedStartFen = startFen === 'start' ? undefined : startFen;
            
            // Start from initial position
            boardInstance.position(normalizedStartFen || 'start');
            
            // Create a chess game to track the position - use new Chess() for default start
            let currentGame = new Chess(normalizedStartFen);
            console.log('Chess game initialized. FEN:', currentGame.fen());
            console.log('Legal moves from start:', currentGame.moves({ verbose: true }).length);
            
            let moveIndex = 0;
            
            // Animate each move
            function playNextMove() {
                if (moveIndex >= moves.length) {
                    // Animation complete, add highlights if any
                    console.log('Animation complete');
                    if (highlightSquares.length > 0 && boardId) {
                        setTimeout(() => {
                            addSquareHighlights(boardId, highlightSquares);
                        }, 300);
                    }
                    return;
                }
                
                const moveNotation = moves[moveIndex].trim();
                console.log(`Playing move ${moveIndex + 1}/${moves.length}: ${moveNotation}`);
                console.log('Current FEN:', currentGame.fen());
                
                try {
                    // Get all legal moves to find the matching one
                    const legalMoves = currentGame.moves({ verbose: true });
                    console.log('Legal moves available:', legalMoves.length, legalMoves.map(m => m.san));
                    
                    if (legalMoves.length === 0) {
                        console.error('No legal moves available! Game might be over or invalid.');
                        moveIndex++;
                        setTimeout(playNextMove, 100);
                        return;
                    }
                    
                    // Try to find the move by SAN notation
                    let move = legalMoves.find(m => m.san === moveNotation);
                    
                    // If not found, try without any move number prefix
                    if (!move) {
                        const moveWithoutNumber = moveNotation.replace(/^\d+\.\s*/, '');
                        move = legalMoves.find(m => m.san === moveWithoutNumber);
                    }
                    
                    // Try case-insensitive match
                    if (!move) {
                        move = legalMoves.find(m => m.san.toLowerCase() === moveNotation.toLowerCase());
                    }
                    
                    if (move) {
                        console.log('Found move:', move);
                        // Apply the move using the verbose format (from/to)
                        const appliedMove = currentGame.move({
                            from: move.from,
                            to: move.to,
                            promotion: move.promotion
                        });
                        
                        if (appliedMove) {
                            const newPosition = currentGame.fen();
                            console.log('Move applied successfully. New FEN:', newPosition);
                            
                            // Animate the move by updating board position
                            boardInstance.position(newPosition);
                            moveIndex++;
                            
                            // Wait before next move (800ms delay)
                            setTimeout(playNextMove, 800);
                        } else {
                            console.error('Failed to apply move:', move);
                            // Try using SAN string as fallback
                            try {
                                const sanMove = currentGame.move(move.san);
                                if (sanMove) {
                                    boardInstance.position(currentGame.fen());
                                    moveIndex++;
                                    setTimeout(playNextMove, 800);
                                } else {
                                    moveIndex++;
                                    setTimeout(playNextMove, 100);
                                }
                            } catch (e) {
                                console.error('SAN fallback also failed:', e);
                                moveIndex++;
                                setTimeout(playNextMove, 100);
                            }
                        }
                    } else {
                        console.warn('Could not find move:', moveNotation, 'Legal moves:', legalMoves.map(m => m.san));
                        // Try direct SAN move as fallback
                        try {
                            const directMove = currentGame.move(moveNotation);
                            if (directMove) {
                                const newPosition = currentGame.fen();
                                console.log('Direct move succeeded. New FEN:', newPosition);
                                boardInstance.position(newPosition);
                                moveIndex++;
                                setTimeout(playNextMove, 800);
                            } else {
                                console.error('Direct move returned null');
                                moveIndex++;
                                setTimeout(playNextMove, 100);
                            }
                        } catch (e) {
                            console.error('Direct move failed:', e);
                            moveIndex++;
                            setTimeout(playNextMove, 100);
                        }
                    }
                } catch (e) {
                    console.error('Error animating move:', e, moveNotation);
                    moveIndex++;
                    setTimeout(playNextMove, 100);
                }
            }
            
            // Start animation after a short delay
            console.log('Starting animation in 500ms...');
            setTimeout(playNextMove, 500);
        }

        /**
         * Adds a message to the chat.
         * Creates mini-board with highlighting for coach messages.
         * Supports animated move sequences for opening demonstrations.
         */
        function addCoachMessage(type, message, fen = null, highlightSquares = [], moveSequence = null) {
            console.log('addCoachMessage called with:', { type, message: message.substring(0, 100), fen, highlightSquares, moveSequence });
            
            const messageDiv = $('<div>').addClass('message').addClass(type);
            
            let header = '';
            if (type === 'coach') header = 'üéì Coach';
            else if (type === 'player') header = 'üë§ You';
            else if (type === 'system') header = 'üì¢ System';
            
            if (header) {
                messageDiv.append($('<div>').addClass('message-header').text(header));
            }
            
            const content = $('<div>').addClass('message-content').text(message);
            messageDiv.append(content);
            
            // Add to DOM first
            $('#coachingChat').append(messageDiv);
            $('#coachingChat').scrollTop($('#coachingChat')[0].scrollHeight);
            
            // Add mini board visualization if FEN provided or move sequence provided
            const hasMoveSequence = moveSequence && Array.isArray(moveSequence) && moveSequence.length > 0;
            console.log('Has move sequence?', hasMoveSequence, moveSequence);
            
            if ((fen || hasMoveSequence) && type === 'coach') {
                console.log('Creating mini board...');
                const miniId = 'mini-' + Date.now();
                const miniDiv = $('<div>').attr('id', miniId).addClass('mini-board-img').css({
                    'position': 'relative',
                    'width': '100%',
                    'max-width': '320px',
                    'height': 'auto',
                    'aspect-ratio': '1',
                    'margin': '15px 0',
                    'border': '1px solid rgba(0, 0, 0, 0.1)',
                    'border-radius': '6px',
                    'box-shadow': '0 1px 4px rgba(0, 0, 0, 0.08)'
                });
                messageDiv.append(miniDiv);
                
                // Create mini board after DOM insertion
                setTimeout(() => {
                    try {
                        // Verify element exists in DOM
                        const element = document.getElementById(miniId);
                        if (!element) {
                            console.warn('Mini board element not found in DOM:', miniId);
                            return;
                        }
                        
                        // Use local piece images
                        const pieceTheme = 'chess_images/chesspieces/wikipedia/{piece}.png';
                        
                        // Determine starting position
                        const startPosition = hasMoveSequence ? 'start' : (fen || 'start');
                        
                        // Create board using just the ID string (no #)
                        const miniBoard = Chessboard(miniId, {
                            position: startPosition,
                            draggable: false,
                            showNotation: false,
                            pieceTheme: pieceTheme
                        });
                        
                        // If we have a move sequence, animate it
                        if (hasMoveSequence) {
                            console.log('Starting animation with moves:', moveSequence);
                            animateMovesOnMiniBoard(miniBoard, moveSequence, startPosition, highlightSquares, miniId);
                        } else {
                            // Just show the final position and add highlights
                            setTimeout(() => {
                                if (fen) {
                                    miniBoard.position(fen);
                                }
                                if (highlightSquares.length > 0) {
                                    addSquareHighlights(miniId, highlightSquares);
                                }
                            }, 300);
                        }
                    } catch (error) {
                        console.error('Error creating mini board:', error, miniId);
                        // Remove the div if board creation failed
                        $('#' + miniId).remove();
                    }
                }, 200);
            }
        }
        
        function addSquareHighlights(boardId, squares) {
            const $board = $('#' + boardId);
            if ($board.length === 0) return;
            
            // Limit to first 3 mentioned squares to avoid clutter
            const squaresToHighlight = squares.slice(0, 3);
            
            // Add highlights to mentioned squares
            squaresToHighlight.forEach((square, index) => {
                // Find the square element by data-square attribute or class
                let $square = $board.find(`[data-square="${square}"]`);
                
                // If not found by data-square, try finding by square- class
                if ($square.length === 0) {
                    $square = $board.find(`[class*="square-${square}"]`);
                }
                
                // Try finding by square index if still not found
                if ($square.length === 0) {
                    const file = square.charCodeAt(0) - 97; // a=0, b=1, etc.
                    const rank = 8 - parseInt(square.charAt(1)); // 1=7, 2=6, etc.
                    const squareIndex = rank * 8 + file;
                    const allSquares = $board.find('[class*="square-"]');
                    if (allSquares.length > squareIndex) {
                        $square = $(allSquares[squareIndex]);
                    }
                }
                
                if ($square.length > 0) {
                    // Create highlight overlay with different colors for each
                    const colors = [
                        { bg: 'rgba(255, 255, 0, 0.5)', border: '#ffcc00' },  // Yellow for primary
                        { bg: 'rgba(0, 255, 255, 0.4)', border: '#00ccff' },  // Cyan for secondary
                        { bg: 'rgba(255, 0, 255, 0.4)', border: '#ff00ff' }   // Magenta for tertiary
                    ];
                    
                    const colorSet = colors[index] || colors[0];
                    
                    const $highlight = $('<div>')
                        .addClass('square-highlight')
                        .css({
                            'position': 'absolute',
                            'top': '0',
                            'left': '0',
                            'right': '0',
                            'bottom': '0',
                            'background': colorSet.bg,
                            'border': '3px solid ' + colorSet.border,
                            'pointer-events': 'none',
                            'z-index': '1',
                            'box-sizing': 'border-box',
                            'border-radius': '3px'
                        });
                    
                    $square.css('position', 'relative').append($highlight);
                }
            });
        }

        function updateStatus() {
            let status = '';
            
            if (game.in_checkmate()) {
                status = 'Checkmate! Game over.';
                gameStarted = false;
            } else if (game.in_draw()) {
                status = 'Draw! Game over.';
                gameStarted = false;
            } else if (game.in_stalemate()) {
                status = 'Stalemate! Game over.';
                gameStarted = false;
            } else if (game.in_check()) {
                status = 'Check!';
            } else {
                status = 'In progress';
            }
            
            $('#gameStatus').text(status);
            
            const turn = game.turn() === 'w' ? 'White' : 'Black';
            $('#turnIndicator').text(turn);
            
            // Calculate material
            updateMaterial();
        }

        function updateMaterial() {
            const pieces = {
                'p': 1, 'n': 3, 'b': 3, 'r': 5, 'q': 9,
                'P': 1, 'N': 3, 'B': 3, 'R': 5, 'Q': 9
            };
            
            let whiteValue = 0;
            let blackValue = 0;
            
            const board = game.board();
            for (let row of board) {
                for (let square of row) {
                    if (square) {
                        if (square.color === 'w') {
                            whiteValue += pieces[square.type.toUpperCase()] || 0;
                        } else {
                            blackValue += pieces[square.type.toLowerCase()] || 0;
                        }
                    }
                }
            }
            
            const diff = whiteValue - blackValue;
            let materialText = '';
            
            if (diff > 0) {
                materialText = `White +${diff}`;
            } else if (diff < 0) {
                materialText = `Black +${Math.abs(diff)}`;
            } else {
                materialText = 'Equal';
            }
            
            $('#materialCount').text(materialText);
        }

        function updateMoveHistory() {
            const moves = game.history();
            let html = '';
            
            for (let i = 0; i < moves.length; i += 2) {
                const moveNum = Math.floor(i / 2) + 1;
                const whiteMove = moves[i];
                const blackMove = moves[i + 1] || '';
                
                html += `
                    <div class="move-item">
                        <span>${moveNum}.</span>
                        <span>${whiteMove}</span>
                        <span>${blackMove}</span>
                    </div>
                `;
            }
            
            $('#moveList').html(html || '<p style="color: #999; padding: 8px;">No moves yet</p>');
            // Scroll to bottom of move list
            $('#moveList').scrollTop($('#moveList')[0].scrollHeight);
        }

        function undoLastMove() {
            if (moveHistory.length < 2) {
                addCoachMessage('system', 'No moves to undo.');
                return;
            }
            
            // Undo last two moves (player + AI)
            game.undo();
            game.undo();
            
            moveHistory.pop();
            moveHistory.pop();
            
            board.position(game.fen());
            updateStatus();
            updateMoveHistory();
            
            addCoachMessage('system', 'Last move undone. Try a different approach!');
        }
        
        } // End of initializeChessApp()
    </script>
</body>
</html>

