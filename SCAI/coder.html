<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Professional Qualitative Coding Tool with AI Learning</title>
    <!-- Papa Parse for CSV handling -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <style>
        :root {
            --primary-color: #0866ff;
            --primary-hover: #0653d1;
            --bg-color: #f0f2f5;
            --card-bg: #ffffff;
            --text-color: #1c1e21;
            --subtle-text: #606770;
            --border-color: #ddd;
            --shadow: 0 1px 3px rgba(0,0,0,0.12);
            /* Define a palette of highlight colors */
            --highlight-bg-1: rgba(255, 210, 70, 0.5); --highlight-border-1: #FFD246;
            --highlight-bg-2: rgba(132, 225, 147, 0.5); --highlight-border-2: #84E193;
            --highlight-bg-3: rgba(131, 195, 255, 0.5); --highlight-border-3: #83C3FF;
            --highlight-bg-4: rgba(255, 156, 156, 0.5); --highlight-border-4: #FF9C9C;
            --highlight-bg-5: rgba(200, 162, 255, 0.5); --highlight-border-5: #C8A2FF;
            --highlight-bg-6: rgba(255, 179, 114, 0.5); --highlight-border-6: #FFB372;
            --highlight-bg-7: rgba(114, 239, 219, 0.5); --highlight-border-7: #72EFDB;
            --highlight-bg-8: rgba(245, 183, 238, 0.5); --highlight-border-8: #F5B7EE;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0; padding: 20px; line-height: 1.6;
        }

        .container { display: grid; grid-template-columns: 2fr 1fr; gap: 20px; max-width: 1400px; margin: auto; }
        header { grid-column: 1 / -1; margin-bottom: 10px; }
        h1, h2, h3 { color: var(--text-color); }
        h1 { font-size: 2em; margin-bottom: 0; }
        header p { font-size: 1.1em; color: var(--subtle-text); }
        main { display: flex; flex-direction: column; gap: 20px; }
        .card { background-color: var(--card-bg); border-radius: 8px; padding: 20px; box-shadow: var(--shadow); }
        .file-inputs { display: flex; flex-direction: column; gap: 15px; margin-bottom: 20px; }
        .file-inputs > div { flex: 1; }
        .mapping-grid { display: grid; grid-template-columns: auto 1fr; gap: 10px 15px; align-items: center; margin: 20px 0; }
        label { font-weight: 600; display: block; margin-bottom: 5px; }
        input[type="file"], input[type="password"], select { width: 100%; padding: 8px; border: 1px solid var(--border-color); border-radius: 4px; box-sizing: border-box; background-color: #f6f7f8; }
        
        button { background-color: var(--primary-color); color: white; border: none; padding: 10px 15px; border-radius: 6px; font-size: 1em; font-weight: bold; cursor: pointer; transition: background-color 0.2s; display: inline-flex; align-items: center; gap: 8px; }
        button:hover:not(:disabled) { background-color: var(--primary-hover); }
        button:disabled { background-color: #a0a0a0; cursor: not-allowed; }

        #text-display-area { background-color: #fcfcfc; border: 1px solid var(--border-color); border-radius: 4px; padding: 15px; height: 350px; overflow-y: auto; line-height: 1.8; font-size: 1.1em; white-space: pre-wrap; }
        #text-display-area::selection { background-color: #b3d4fc; }

        .highlighted-text { border-radius: 3px; padding: 2px 0; cursor: pointer; }
        .highlight-color-1 { background-color: var(--highlight-bg-1); border-bottom: 2px solid var(--highlight-border-1); }
        .highlight-color-2 { background-color: var(--highlight-bg-2); border-bottom: 2px solid var(--highlight-border-2); }
        .highlight-color-3 { background-color: var(--highlight-bg-3); border-bottom: 2px solid var(--highlight-border-3); }
        .highlight-color-4 { background-color: var(--highlight-bg-4); border-bottom: 2px solid var(--highlight-border-4); }
        .highlight-color-5 { background-color: var(--highlight-bg-5); border-bottom: 2px solid var(--highlight-border-5); }
        .highlight-color-6 { background-color: var(--highlight-bg-6); border-bottom: 2px solid var(--highlight-border-6); }
        .highlight-color-7 { background-color: var(--highlight-bg-7); border-bottom: 2px solid var(--highlight-border-7); }
        .highlight-color-8 { background-color: var(--highlight-bg-8); border-bottom: 2px solid var(--highlight-border-8); }
        
        #progress-table-container { max-height: 60vh; overflow-y: auto; }
        #progress-table { width: 100%; border-collapse: collapse; margin-top: 15px; }
        #progress-table th, #progress-table td { border: 1px solid var(--border-color); padding: 8px; text-align: left; }
        #progress-table th { background-color: #f6f7f8; position: sticky; top: 0; }
        #progress-table td { word-break: break-word; }

        /* Updated context menu styles for click navigation */
        #context-menu { 
            position: absolute; 
            display: none; 
            background-color: var(--card-bg); 
            border-radius: 8px; 
            box-shadow: 0 8px 20px rgba(0,0,0,0.15); 
            z-index: 1000; 
            padding: 8px 0; 
            min-width: 220px; 
            max-width: 300px;
            border: 1px solid var(--border-color);
        }
        
        .menu-header {
            padding: 8px 16px;
            background-color: #f8f9fa;
            border-bottom: 1px solid var(--border-color);
            font-weight: 600;
            font-size: 0.9em;
            color: var(--subtle-text);
        }
        
        .menu-item {
            padding: 10px 16px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
            transition: background-color 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .menu-item:last-child {
            border-bottom: none;
        }
        
        .menu-item:hover {
            background-color: #f8f9fa;
        }
        
        .menu-item.has-children::after {
            content: '›';
            font-size: 1.2em;
            color: var(--subtle-text);
        }
        
        .menu-item.back-button {
            background-color: #f0f2f5;
            font-weight: 600;
            border-bottom: 2px solid var(--border-color);
        }
        
        .menu-item.back-button::before {
            content: '‹ ';
            font-size: 1.2em;
        }
        
        .menu-item.apply-code {
            background-color: #e3f2fd;
            color: var(--primary-color);
            font-weight: 600;
        }
        
        .menu-item.apply-code:hover {
            background-color: var(--primary-color);
            color: white;
        }

        #prompt-navigation { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        #prompt-display { font-weight: bold; font-size: 1.1em; }
        
        .ai-settings { 
            background-color: #f6f7f8; 
            padding: 15px; 
            border-radius: 6px; 
            margin-top: 15px;
            display: none;
        }
        .ai-settings.show { display: block; }
        .ai-settings label { margin-top: 10px; }
        .ai-settings textarea { 
            width: 100%; 
            min-height: 100px; 
            margin-top: 5px;
            font-family: monospace;
            font-size: 0.9em;
        }
        
        .ai-status {
            margin-top: 10px;
            padding: 10px;
            border-radius: 4px;
            background-color: #e3f2fd;
            color: #1976d2;
            font-size: 0.9em;
            display: none;
        }
        .ai-status.show { display: block; }
        .ai-status.error { background-color: #ffebee; color: #c62828; }
        .ai-status.success { background-color: #e8f5e9; color: #2e7d32; }
        
        .learning-stats {
            background-color: #e8f5e9;
            border: 1px solid #4caf50;
            border-radius: 4px;
            padding: 10px;
            margin-top: 10px;
            font-size: 0.9em;
            display: none;
        }
        .learning-stats.show { display: block; }
        .learning-stats strong { color: #2e7d32; }

        .examples-section {
            margin-top: 15px;
            padding: 10px;
            background-color: #f0f8ff;
            border-radius: 4px;
            border-left: 4px solid var(--primary-color);
            font-size: 0.9em;
        }
        
        .hidden { display: none; }
        .loading-spinner {
            display: inline-block;
            width: 16px; height: 16px;
            border: 2px solid rgba(255,255,255,.3);
            border-radius: 50%; border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        @media (min-width: 768px) { .file-inputs { flex-direction: row; gap: 20px; } }
        @media (max-width: 900px) {
            .container { grid-template-columns: 1fr; }
            header { text-align: center; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>🧠 HITL Qualitative Coding Tool</h1>
            <p>The AI learns from your coding examples to improve automatic coding accuracy. Highlight text to code manually, or let AI learn from your patterns.</p>
        </header>
        <main>
            <div id="setup-section" class="card">
                <h2>1. Setup</h2>
                <div class="file-inputs">
                    <div><label for="data-file">Upload Data CSV</label><input type="file" id="data-file" accept=".csv"></div>
                    <div><label for="codebook-file">Upload Codebook CSV</label><input type="file" id="codebook-file" accept=".csv"></div>
                    <div><label for="progress-file">Optional: Upload Saved Progress</label><input type="file" id="progress-file" accept=".csv"></div>
                </div>
                <div>
                    <label for="api-key">OpenAI API Key</label>
                    <input type="password" id="api-key" placeholder="Enter your OpenAI API key here">
                </div>
                <div id="column-mapping-section" class="hidden">
                    <h3>Map Your Columns</h3>
                    <div class="mapping-grid">
                        <label for="id-col">Unique ID Column:</label><select id="id-col"></select>
                        <label for="text-col">Text to Code Column:</label><select id="text-col"></select>
                        <label for="open-code-col">Open Code Column:</label><select id="open-code-col"></select>
                        <label for="axial-code-col">Axial Code Column:</label><select id="axial-code-col"></select>
                        <label for="selective-code-col">Selective Code Column:</label><select id="selective-code-col"></select>
                    </div><button id="start-coding-btn">Start Coding</button>
                </div>
            </div>
            <div id="coding-section" class="card hidden">
                <h2>2. Code Your Text</h2>
                <div id="prompt-navigation">
                    <button id="back-btn" disabled>Back</button>
                    <div>
                        <button id="ai-coder-btn" disabled>
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M9.05.435c-.58-.58-1.52-.58-2.1 0L4.047 3.339 8 7.293l3.954-3.954L9.049.435zm3.61 3.611L8.708 8l3.954 3.954 2.904-2.905c.58-.58.58-1.519 0-2.098l-2.904-2.905zm-.706 8.642L8 8.708l-3.954 3.954 2.905 2.904c.58.58 1.519.58 2.098 0l2.905-2.904zm-8.642-.706L7.292 8 3.339 4.046.435 6.951c-.58.58-.58 1.519 0 2.098l2.904 2.905z"/></svg>
                            <span id="ai-coder-btn-text">Smart AI Coder</span>
                        </button>
                        <button id="ai-settings-toggle" style="margin-left: 5px;">⚙️</button>
                    </div>
                    <div id="prompt-display"></div>
                    <button id="next-btn" disabled>Next</button>
                </div>
                <div class="ai-settings" id="ai-settings">
                    <h4>AI Coder Settings</h4>
                    <label for="ai-model">Model:</label>
                    <select id="ai-model">
                        <option value="gpt-4o" selected>GPT-4o (Recommended)</option>
                        <option value="gpt-4-turbo">GPT-4 Turbo</option>
                        <option value="gpt-3.5-turbo">GPT-3.5 Turbo (Faster, less accurate)</option>
                    </select>
                    
                    <label for="ai-instructions">Additional Instructions for AI:</label>
                    <textarea id="ai-instructions" placeholder="E.g., 'Focus on emotional expressions', 'Look for technical terms', 'Be conservative with coding'"></textarea>
                    
                    <label>
                        <input type="checkbox" id="ai-fuzzy-match" checked>
                        Enable fuzzy matching (handles minor text differences)
                    </label>
                    
                    <label for="max-examples">Max examples to use for learning:</label>
                    <select id="max-examples">
                        <option value="5">5 examples per code</option>
                        <option value="10" selected>10 examples per code</option>
                        <option value="15">15 examples per code</option>
                        <option value="20">20 examples per code</option>
                    </select>
                    
                    <div class="learning-stats" id="learning-stats">
                        <strong>🧠 Learning Status:</strong>
                        <div id="learning-details"></div>
                    </div>
                </div>
                <div class="ai-status" id="ai-status"></div>
                <div id="text-display-area"></div>
            </div>
        </main>
        <aside>
            <div id="progress-section" class="card">
                <h2 id="progress-title">All Coding Progress</h2>
                <button id="save-progress-btn" class="hidden">💾 Save All Progress to CSV</button>
                <div id="progress-table-container">
                    <p id="no-codes-msg">No codes have been applied yet.</p>
                    <table id="progress-table" class="hidden">
                        <thead><tr><th>ID</th><th>Highlighted Text</th><th>Open Code</th><th>Axial Code</th><th>Selective Code</th></tr></thead>
                        <tbody></tbody>
                    </table>
                </div>
            </div>
        </aside>
    </div>
    <div id="context-menu"></div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- STATE MANAGEMENT ---
        let state = {
            data: [], codebook: {}, codedData: [], columnMapping: {}, hierarchicalCodebook: {},
            currentPromptIndex: -1,
            apiKey: '',
            selectiveCodeToColor: new Map(),
            colorPalette: [1, 2, 3, 4, 5, 6, 7, 8],
            aiSettings: {
                model: 'gpt-4o',
                additionalInstructions: '',
                fuzzyMatch: true,
                maxExamples: 10
            },
            // Menu navigation state
            menuState: {
                currentLevel: 'selective', // 'selective', 'axial', 'open'
                selectedSelective: null,
                selectedAxial: null,
                selectedText: null,
                selection: null
            },
            // NEW: Learning system state
            learningExamples: new Map(), // code -> array of examples
            learningStats: {
                totalExamples: 0,
                codesWithExamples: 0,
                lastUpdated: null
            }
        };

        // --- DOM ELEMENTS ---
        const elements = {
            dataFileInput: document.getElementById('data-file'), codebookFileInput: document.getElementById('codebook-file'),
            progressFileInput: document.getElementById('progress-file'), apiKeyInput: document.getElementById('api-key'),
            columnMappingSection: document.getElementById('column-mapping-section'),
            startCodingBtn: document.getElementById('start-coding-btn'), codingSection: document.getElementById('coding-section'),
            setupSection: document.getElementById('setup-section'), textDisplayArea: document.getElementById('text-display-area'),
            progressTableBody: document.querySelector('#progress-table tbody'), progressTable: document.getElementById('progress-table'),
            saveProgressBtn: document.getElementById('save-progress-btn'), noCodesMsg: document.getElementById('no-codes-msg'),
            contextMenu: document.getElementById('context-menu'), backBtn: document.getElementById('back-btn'),
            nextBtn: document.getElementById('next-btn'), promptDisplay: document.getElementById('prompt-display'),
            progressTitle: document.getElementById('progress-title'), aiCoderBtn: document.getElementById('ai-coder-btn'),
            aiCoderBtnText: document.getElementById('ai-coder-btn-text'),
            aiSettingsToggle: document.getElementById('ai-settings-toggle'),
            aiSettings: document.getElementById('ai-settings'),
            aiModel: document.getElementById('ai-model'),
            aiInstructions: document.getElementById('ai-instructions'),
            aiFuzzyMatch: document.getElementById('ai-fuzzy-match'),
            aiStatus: document.getElementById('ai-status'),
            maxExamples: document.getElementById('max-examples'),
            learningStats: document.getElementById('learning-stats'),
            learningDetails: document.getElementById('learning-details')
        };

        // --- AI Settings Toggle ---
        elements.aiSettingsToggle.addEventListener('click', () => {
            elements.aiSettings.classList.toggle('show');
        });

        elements.aiModel.addEventListener('change', (e) => {
            state.aiSettings.model = e.target.value;
        });

        elements.aiInstructions.addEventListener('input', (e) => {
            state.aiSettings.additionalInstructions = e.target.value;
        });

        elements.aiFuzzyMatch.addEventListener('change', (e) => {
            state.aiSettings.fuzzyMatch = e.target.checked;
        });

        elements.maxExamples.addEventListener('change', (e) => {
            state.aiSettings.maxExamples = parseInt(e.target.value);
            updateLearningStats();
        });

        // --- LEARNING SYSTEM FUNCTIONS ---
        function updateLearningExamples() {
            // Clear and rebuild learning examples from all coded data
            state.learningExamples.clear();
            
            state.codedData.forEach(codeData => {
                const openCode = codeData['Open Code'];
                const highlightedText = codeData['Highlighted Text'];
                const fullTextId = codeData['ID'];
                
                if (openCode && highlightedText) {
                    if (!state.learningExamples.has(openCode)) {
                        state.learningExamples.set(openCode, []);
                    }
                    
                    // Find the full text context for this example
                    const fullTextRow = state.data.find(row => 
                        String(row[state.columnMapping.id]) === String(fullTextId)
                    );
                    const fullText = fullTextRow ? fullTextRow[state.columnMapping.text] : '';
                    
                    state.learningExamples.get(openCode).push({
                        highlightedText: highlightedText,
                        fullText: fullText,
                        axialCode: codeData['Axial Code'],
                        selectiveCode: codeData['Selective Code'],
                        id: fullTextId
                    });
                }
            });
            
            updateLearningStats();
        }
        
        function updateLearningStats() {
            const totalExamples = Array.from(state.learningExamples.values())
                .reduce((sum, examples) => sum + examples.length, 0);
            const codesWithExamples = state.learningExamples.size;
            
            state.learningStats = {
                totalExamples: totalExamples,
                codesWithExamples: codesWithExamples,
                lastUpdated: new Date()
            };
            
            if (totalExamples > 0) {
                elements.learningStats.classList.add('show');
                elements.learningDetails.innerHTML = `
                    ${totalExamples} examples across ${codesWithExamples} codes<br>
                    <small>Last updated: ${state.learningStats.lastUpdated.toLocaleTimeString()}</small>
                `;
            } else {
                elements.learningStats.classList.remove('show');
            }
        }
        
        function getRelevantExamples(currentText, maxExamples = null) {
            const examplesToUse = maxExamples || state.aiSettings.maxExamples;
            const relevantExamples = [];
            
            // Get examples for each code, prioritizing by text similarity
            state.learningExamples.forEach((examples, openCode) => {
                // Score examples by text similarity to current text
                const scoredExamples = examples.map(example => ({
                    ...example,
                    similarity: calculateTextSimilarity(currentText, example.fullText)
                }));
                
                // Sort by similarity and take top examples
                scoredExamples.sort((a, b) => b.similarity - a.similarity);
                const topExamples = scoredExamples.slice(0, Math.min(examplesToUse, examples.length));
                
                relevantExamples.push(...topExamples.map(example => ({
                    openCode: openCode,
                    ...example
                })));
            });
            
            // Sort all examples by similarity and return top ones
            relevantExamples.sort((a, b) => b.similarity - a.similarity);
            return relevantExamples.slice(0, 50); // Limit total examples to prevent token overflow
        }
        
        function calculateTextSimilarity(text1, text2) {
            // Simple word-based similarity calculation
            const words1 = text1.toLowerCase().split(/\s+/);
            const words2 = text2.toLowerCase().split(/\s+/);
            
            const set1 = new Set(words1);
            const set2 = new Set(words2);
            
            const intersection = new Set([...set1].filter(x => set2.has(x)));
            const union = new Set([...set1, ...set2]);
            
            return intersection.size / union.size; // Jaccard similarity
        }
        
        function buildLearningPrompt(currentText) {
            const relevantExamples = getRelevantExamples(currentText);
            
            if (relevantExamples.length === 0) {
                return "";
            }
            
            let learningSection = "\n\n## LEARNING FROM YOUR PREVIOUS CODING EXAMPLES:\n";
            learningSection += "The following examples show how you have previously applied codes to similar text. Use these patterns to guide your coding of the current text:\n\n";
            
            // Group examples by code
            const examplesByCode = {};
            relevantExamples.forEach(example => {
                if (!examplesByCode[example.openCode]) {
                    examplesByCode[example.openCode] = [];
                }
                examplesByCode[example.openCode].push(example);
            });
            
            Object.entries(examplesByCode).forEach(([openCode, examples]) => {
                learningSection += `**${openCode}** examples:\n`;
                examples.slice(0, 3).forEach((example, index) => { // Limit to 3 examples per code
                    learningSection += `${index + 1}. "${example.highlightedText}"\n`;
                    if (example.fullText.length < 200) {
                        learningSection += `   Context: "${example.fullText}"\n`;
                    }
                });
                learningSection += "\n";
            });
            
            learningSection += "Use these examples to understand the patterns and context for applying each code. Look for similar language, themes, and contexts in the current text.\n";
            
            return learningSection;
        }

        // --- FILE HANDLING & SETUP ---
        const handleFile = (file, callback) => {
            if (!file) return;
            Papa.parse(file, { header: true, skipEmptyLines: true, complete: (res) => callback(res.data, res.meta.fields) });
        };
        const checkFilesAndShowMapping = () => {
            if (state.data.length > 0 && state.codebook.raw && state.codebook.raw.length > 0) {
                elements.columnMappingSection.classList.remove('hidden');
            }
        };
        elements.dataFileInput.addEventListener('change', (e) => handleFile(e.target.files[0], (d, h) => { state.data = d; populateSelect('id-col', h); populateSelect('text-col', h); checkFilesAndShowMapping(); }));
        elements.codebookFileInput.addEventListener('change', (e) => handleFile(e.target.files[0], (d, h) => { state.codebook.raw = d; populateSelect('open-code-col', h); populateSelect('axial-code-col', h); populateSelect('selective-code-col', h); checkFilesAndShowMapping(); }));
        
        elements.progressFileInput.addEventListener('change', (e) => handleFile(e.target.files[0], (d) => {
            const requiredKeys = ['uuid', 'ID', 'Highlighted Text', 'Open Code', 'Axial Code', 'Selective Code', 'startIndex'];
            state.codedData = d.map(row => {
                const newRow = {};
                for (const key of requiredKeys) {
                    const actualKey = Object.keys(row).find(k => k.toLowerCase().replace(/\s/g, '') === key.toLowerCase().replace(/\s/g, ''));
                    newRow[key] = actualKey ? row[actualKey] : '';
                }
                if (!newRow.uuid) newRow.uuid = Date.now() + '-' + Math.random().toString(36).substr(2, 9);
                return newRow;
            });
            alert(`${state.codedData.length} progress entries loaded.`);
            updateLearningExamples(); // Update learning examples when progress is loaded
            updateProgressTable(); 
            if (state.currentPromptIndex > -1) renderCurrentPrompt();
        }));

        const populateSelect = (id, opts) => {
            const sel = document.getElementById(id); sel.innerHTML = '';
            opts.forEach(o => { const opt = document.createElement('option'); opt.value = o; opt.textContent = o; sel.appendChild(opt); });
        };

        elements.startCodingBtn.addEventListener('click', () => {
            state.apiKey = elements.apiKeyInput.value.trim();
            if (!state.apiKey) {
                alert('Please enter your OpenAI API key to enable the AI Coder.');
            }
            state.columnMapping = { id: document.getElementById('id-col').value, text: document.getElementById('text-col').value, open: document.getElementById('open-code-col').value, axial: document.getElementById('axial-code-col').value, selective: document.getElementById('selective-code-col').value };
            state.hierarchicalCodebook = {};
            state.codebook.raw.forEach(row => {
                const sel = row[state.columnMapping.selective], axi = row[state.columnMapping.axial], opn = row[state.columnMapping.open];
                if (!sel || !axi || !opn) return;
                if (!state.hierarchicalCodebook[sel]) state.hierarchicalCodebook[sel] = {};
                if (!state.hierarchicalCodebook[sel][axi]) state.hierarchicalCodebook[sel][axi] = [];
                state.hierarchicalCodebook[sel][axi].push(opn);
            });
            elements.setupSection.classList.add('hidden');
            elements.codingSection.classList.remove('hidden');
            if (state.data.length > 0) {
                state.currentPromptIndex = 0;
                renderCurrentPrompt();
            }
            updateLearningExamples(); // Initialize learning examples
        });

        // --- NAVIGATION & AI ---
        elements.backBtn.addEventListener('click', () => navigate(-1));
        elements.nextBtn.addEventListener('click', () => navigate(1));
        elements.aiCoderBtn.addEventListener('click', handleAiCoding);

        const navigate = (direction) => {
            if (state.currentPromptIndex + direction >= 0 && state.currentPromptIndex + direction < state.data.length) {
                state.currentPromptIndex += direction;
                renderCurrentPrompt();
            }
        };
        const updateNavButtons = () => {
            elements.backBtn.disabled = state.currentPromptIndex <= 0;
            elements.nextBtn.disabled = state.currentPromptIndex >= state.data.length - 1;
            elements.aiCoderBtn.disabled = !state.apiKey;
        };

        // --- RENDERING & DISPLAY ---
        const renderCurrentPrompt = () => {
            if (state.currentPromptIndex === -1) return;
            const currentPrompt = state.data[state.currentPromptIndex];
            const promptId = currentPrompt[state.columnMapping.id];
            const originalText = currentPrompt[state.columnMapping.text] || "";
            
            elements.promptDisplay.textContent = `Prompt ${state.currentPromptIndex + 1} of ${state.data.length} (ID: ${promptId})`;
            elements.textDisplayArea.innerHTML = generateHighlightedHTML(promptId, originalText);
            
            updateProgressTable(promptId);
            updateNavButtons();
        };

        const generateHighlightedHTML = (promptId, originalText) => {
            const codesForThisPrompt = state.codedData.filter(c => String(c.ID) === String(promptId));
            if (!codesForThisPrompt.length) return escapeHtml(originalText);

            let segments = [];
            codesForThisPrompt.forEach(code => {
                const textToFind = code['Highlighted Text'];
                if (!textToFind) return;
                let startIndex = 0;
                while ((startIndex = originalText.indexOf(textToFind, startIndex)) !== -1) {
                    const endIndex = startIndex + textToFind.length;
                    if (!segments.some(s => (startIndex < s.end && endIndex > s.start))) {
                         segments.push({ start: startIndex, end: endIndex, code: code });
                    }
                    startIndex += 1;
                }
            });

            segments.sort((a, b) => a.start - b.start);

            let lastIndex = 0;
            let finalHtml = '';
            segments.forEach(segment => {
                finalHtml += escapeHtml(originalText.substring(lastIndex, segment.start));
                const colorClass = getColorForSelectiveCode(segment.code['Selective Code']);
                const highlightTitle = `Click to remove. Code: ${segment.code['Selective Code']} > ${segment.code['Axial Code']} > ${segment.code['Open Code']}`;
                const highlightHTML = `<mark data-uuid="${segment.code.uuid}" title="${highlightTitle}" class="highlighted-text ${colorClass}">${escapeHtml(segment.code['Highlighted Text'])}</mark>`;
                finalHtml += highlightHTML;
                lastIndex = segment.end;
            });
            finalHtml += escapeHtml(originalText.substring(lastIndex));

            return finalHtml;
        };
        
        const escapeHtml = (unsafe) => {
            if (typeof unsafe !== 'string') return '';
            return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
        }
        
        const getColorForSelectiveCode = (selectiveCode) => {
            if (!state.selectiveCodeToColor.has(selectiveCode)) {
                const colorIndex = (state.selectiveCodeToColor.size % state.colorPalette.length);
                state.selectiveCodeToColor.set(selectiveCode, `highlight-color-${state.colorPalette[colorIndex]}`);
            }
            return state.selectiveCodeToColor.get(selectiveCode);
        };

        // --- ENHANCED CONTEXT MENU SYSTEM (Click-based navigation) ---
        elements.textDisplayArea.addEventListener('click', (e) => {
            const highlightElement = e.target.closest('.highlighted-text');
            if (highlightElement) {
                const uuidToRemove = highlightElement.dataset.uuid;
                if (!uuidToRemove) return;
                const indexToRemove = state.codedData.findIndex(code => code.uuid === uuidToRemove);
                if (indexToRemove > -1) {
                    state.codedData.splice(indexToRemove, 1);
                    updateLearningExamples(); // Update learning when codes are removed
                    renderCurrentPrompt();
                }
            }
        });

        elements.textDisplayArea.addEventListener('mouseup', (e) => {
            const selection = window.getSelection();
            if (selection.isCollapsed || e.target.closest('.highlighted-text')) return;
            const selectedText = selection.toString().trim();
            if (selectedText.length === 0) return;
            
            // Store selection info
            state.menuState.selectedText = selectedText;
            state.menuState.selection = selection;
            state.menuState.currentLevel = 'selective';
            state.menuState.selectedSelective = null;
            state.menuState.selectedAxial = null;
            
            buildAndShowMenu();
        });

        const buildAndShowMenu = () => {
            const menu = elements.contextMenu;
            menu.innerHTML = '';
            
            if (state.menuState.currentLevel === 'selective') {
                buildSelectiveCodeMenu(menu);
            } else if (state.menuState.currentLevel === 'axial') {
                buildAxialCodeMenu(menu);
            } else if (state.menuState.currentLevel === 'open') {
                buildOpenCodeMenu(menu);
            }
            
            positionMenu();
            menu.style.display = 'block';
        };

        const buildSelectiveCodeMenu = (menu) => {
            const header = document.createElement('div');
            header.className = 'menu-header';
            header.textContent = 'Select Selective Code';
            menu.appendChild(header);
            
            const selectiveCodes = Object.keys(state.hierarchicalCodebook);
            selectiveCodes.forEach(selectiveCode => {
                const item = document.createElement('div');
                item.className = 'menu-item has-children';
                item.textContent = selectiveCode;
                item.addEventListener('click', () => {
                    state.menuState.selectedSelective = selectiveCode;
                    state.menuState.currentLevel = 'axial';
                    buildAndShowMenu();
                });
                menu.appendChild(item);
            });
        };

        const buildAxialCodeMenu = (menu) => {
            const header = document.createElement('div');
            header.className = 'menu-header';
            header.textContent = `Selective: ${state.menuState.selectedSelective}`;
            menu.appendChild(header);
            
            // Back button
            const backItem = document.createElement('div');
            backItem.className = 'menu-item back-button';
            backItem.textContent = 'Back to Selective Codes';
            backItem.addEventListener('click', () => {
                state.menuState.currentLevel = 'selective';
                state.menuState.selectedSelective = null;
                buildAndShowMenu();
            });
            menu.appendChild(backItem);
            
            const axialCodes = Object.keys(state.hierarchicalCodebook[state.menuState.selectedSelective]);
            axialCodes.forEach(axialCode => {
                const item = document.createElement('div');
                item.className = 'menu-item has-children';
                item.textContent = axialCode;
                item.addEventListener('click', () => {
                    state.menuState.selectedAxial = axialCode;
                    state.menuState.currentLevel = 'open';
                    buildAndShowMenu();
                });
                menu.appendChild(item);
            });
        };

        const buildOpenCodeMenu = (menu) => {
            const header = document.createElement('div');
            header.className = 'menu-header';
            header.textContent = `${state.menuState.selectedSelective} > ${state.menuState.selectedAxial}`;
            menu.appendChild(header);
            
            // Back button
            const backItem = document.createElement('div');
            backItem.className = 'menu-item back-button';
            backItem.textContent = 'Back to Axial Codes';
            backItem.addEventListener('click', () => {
                state.menuState.currentLevel = 'axial';
                state.menuState.selectedAxial = null;
                buildAndShowMenu();
            });
            menu.appendChild(backItem);
            
            const openCodes = state.hierarchicalCodebook[state.menuState.selectedSelective][state.menuState.selectedAxial];
            openCodes.forEach(openCode => {
                const item = document.createElement('div');
                item.className = 'menu-item apply-code';
                item.textContent = openCode;
                item.addEventListener('click', () => {
                    applyCode(
                        state.menuState.selectedText,
                        openCode,
                        state.menuState.selectedAxial,
                        state.menuState.selectedSelective
                    );
                    hideMenu();
                });
                menu.appendChild(item);
            });
        };

        const positionMenu = () => {
            if (!state.menuState.selection) return;
            
            const range = state.menuState.selection.getRangeAt(0);
            const rect = range.getBoundingClientRect();
            const menu = elements.contextMenu;
            
            let top = rect.bottom + window.scrollY + 5;
            let left = rect.left + window.scrollX;
            
            // Adjust if menu would go off screen
            const menuRect = menu.getBoundingClientRect();
            if (left + 220 > window.innerWidth) {
                left = window.innerWidth - 230;
            }
            if (top + 200 > window.innerHeight + window.scrollY) {
                top = rect.top + window.scrollY - 210;
            }
            
            menu.style.top = `${top}px`;
            menu.style.left = `${left}px`;
        };

        const hideMenu = () => {
            elements.contextMenu.style.display = 'none';
            if (window.getSelection) window.getSelection().removeAllRanges();
            
            // Reset menu state
            state.menuState = {
                currentLevel: 'selective',
                selectedSelective: null,
                selectedAxial: null,
                selectedText: null,
                selection: null
            };
        };

        // Hide menu when clicking outside
        document.addEventListener('mousedown', (e) => {
            if (!elements.contextMenu.contains(e.target) && 
                e.target !== elements.textDisplayArea && 
                !elements.textDisplayArea.contains(e.target)) {
                hideMenu();
            }
        });

        const applyCode = (highlightedText, openCode, axialCode, selectiveCode) => {
            if (!highlightedText) return;
            const currentPrompt = state.data[state.currentPromptIndex];
            const originalText = currentPrompt[state.columnMapping.text] || "";
            const startIndex = originalText.indexOf(highlightedText);
            const currentPromptId = currentPrompt[state.columnMapping.id];

            const uuid = Date.now() + '-' + Math.random().toString(36).substr(2, 9);
            state.codedData.push({ 'uuid': uuid, 'ID': currentPromptId, 'Highlighted Text': highlightedText, 'Open Code': openCode, 'Axial Code': axialCode, 'Selective Code': selectiveCode, 'startIndex': startIndex });
            updateLearningExamples(); // Update learning when new codes are added
            renderCurrentPrompt();
        };

        // --- ENHANCED AI Coder Logic with Learning ---
        
        // Utility function for fuzzy string matching
        function findFuzzyMatches(text, searchString, threshold = 0.85) {
            const matches = [];
            const searchLower = searchString.toLowerCase();
            const searchWords = searchLower.split(/\s+/);
            
            // Try to find approximate matches
            for (let i = 0; i < text.length - searchString.length + 1; i++) {
                const substring = text.substring(i, i + searchString.length + 20); // Get a bit more context
                const substringLower = substring.toLowerCase();
                
                // Check if all words from search string are present
                let allWordsFound = true;
                let lastIndex = 0;
                for (const word of searchWords) {
                    const wordIndex = substringLower.indexOf(word, lastIndex);
                    if (wordIndex === -1) {
                        allWordsFound = false;
                        break;
                    }
                    lastIndex = wordIndex + word.length;
                }
                
                if (allWordsFound) {
                    // Find the exact boundaries
                    const endIndex = lastIndex;
                    const exactMatch = text.substring(i, i + endIndex);
                    
                    // Calculate similarity score
                    const similarity = calculateSimilarity(searchLower, exactMatch.toLowerCase());
                    if (similarity >= threshold) {
                        matches.push({
                            text: exactMatch.trim(),
                            index: i,
                            similarity: similarity
                        });
                    }
                }
            }
            
            // Remove duplicates and return best matches
            const uniqueMatches = [];
            const seen = new Set();
            
            matches.sort((a, b) => b.similarity - a.similarity);
            for (const match of matches) {
                if (!seen.has(match.text)) {
                    seen.add(match.text);
                    uniqueMatches.push(match);
                }
            }
            
            return uniqueMatches;
        }
        
        // Calculate similarity between two strings
        function calculateSimilarity(str1, str2) {
            const longer = str1.length > str2.length ? str1 : str2;
            const shorter = str1.length > str2.length ? str2 : str1;
            
            if (longer.length === 0) return 1.0;
            
            const editDistance = getEditDistance(longer, shorter);
            return (longer.length - editDistance) / longer.length;
        }
        
        // Levenshtein distance implementation
        function getEditDistance(str1, str2) {
            const matrix = [];
            
            for (let i = 0; i <= str2.length; i++) {
                matrix[i] = [i];
            }
            
            for (let j = 0; j <= str1.length; j++) {
                matrix[0][j] = j;
            }
            
            for (let i = 1; i <= str2.length; i++) {
                for (let j = 1; j <= str1.length; j++) {
                    if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1,
                            matrix[i][j - 1] + 1,
                            matrix[i - 1][j] + 1
                        );
                    }
                }
            }
            
            return matrix[str2.length][str1.length];
        }

        async function handleAiCoding() {
            if (!state.apiKey) {
                alert("Please enter your OpenAI API key in the setup section first.");
                return;
            }

            const currentPrompt = state.data[state.currentPromptIndex];
            const textToCode = currentPrompt[state.columnMapping.text];
            const promptId = currentPrompt[state.columnMapping.id];

            // Create a detailed codebook for the AI
            const codebookDetails = state.codebook.raw.map(row => ({
                openCode: row[state.columnMapping.open],
                axialCode: row[state.columnMapping.axial],
                selectiveCode: row[state.columnMapping.selective]
            }));

            const openCodesList = [...new Set(codebookDetails.map(c => c.openCode))].filter(Boolean);

            const tools = [
                {
                    "type": "function",
                    "function": {
                        "name": "code_text_segments",
                        "description": "Extracts text segments from the provided text that correspond to a list of qualitative codes.",
                        "parameters": {
                            "type": "object",
                            "properties": {
                                "codes": {
                                    "type": "array",
                                    "description": "An array of coded text segments.",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "highlightedText": {
                                                "type": "string",
                                                "description": "The exact, verbatim text segment extracted from the source text."
                                            },
                                            "openCode": {
                                                "type": "string",
                                                "description": "The open code that applies to the highlighted text.",
                                                "enum": openCodesList
                                            },
                                            "confidence": {
                                                "type": "number",
                                                "description": "Confidence score (0-1) for this coding decision.",
                                                "minimum": 0,
                                                "maximum": 1
                                            },
                                            "reasoning": {
                                                "type": "string",
                                                "description": "Brief explanation for why this code was applied."
                                            }
                                        },
                                        "required": ["highlightedText", "openCode", "confidence"]
                                    }
                                }
                            },
                            "required": ["codes"]
                        }
                    }
                }
            ];
            
            // Build a comprehensive prompt with learning examples
            const codebookDescription = openCodesList.map(code => {
                const examples = codebookDetails.filter(c => c.openCode === code);
                return `- ${code}: ${examples[0].axialCode} > ${examples[0].selectiveCode}`;
            }).join('\n');
            
            let systemPrompt = `You are an expert qualitative data analysis assistant that learns from previous coding examples. Analyze the user's text and identify ALL segments that correspond to the provided list of open codes. Call the \`code_text_segments\` function with your findings.

CRITICAL INSTRUCTIONS:
1. The 'highlightedText' MUST BE an exact, verbatim substring from the source text.
2. Do NOT rephrase, reformat, or change the text in any way.
3. Include all punctuation, spacing, and formatting exactly as it appears.
4. Be thorough - look for ALL instances where a code might apply.
5. You can code the same text segment with multiple codes if appropriate.
6. Include longer, meaningful passages rather than just individual words when the context is important.
7. Provide confidence scores: 1.0 for clear matches, 0.7-0.9 for probable matches, 0.5-0.7 for possible matches.
8. LEARN from the provided examples to understand the coding patterns and apply them consistently.

Available codes and their hierarchical structure:
${codebookDescription}`;

            // Add learning examples if available
            const learningPrompt = buildLearningPrompt(textToCode);
            if (learningPrompt) {
                systemPrompt += learningPrompt;
            }

            if (state.aiSettings.additionalInstructions) {
                systemPrompt += `\n\nAdditional instructions: ${state.aiSettings.additionalInstructions}`;
            }

            const userPrompt = `Please analyze this text and code it according to the codebook provided${learningPrompt ? ' and the learning examples' : ''}. Be thorough and extract ALL relevant segments.

Text to Analyze:
"""
${textToCode}
"""`;
            
            toggleAiLoading(true);
            showAiStatus(`Analyzing text with AI${state.learningStats.totalExamples > 0 ? ` (using ${state.learningStats.totalExamples} learning examples)` : ''}...`, 'info');

            try {
                const response = await fetch("https://api.openai.com/v1/chat/completions", {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${state.apiKey}`
                    },
                    body: JSON.stringify({
                        model: state.aiSettings.model,
                        messages: [
                            { role: "system", content: systemPrompt },
                            { role: "user", content: userPrompt }
                        ],
                        tools: tools,
                        tool_choice: {"type": "function", "function": {"name": "code_text_segments"}},
                        temperature: 0.3, // Lower temperature for more consistent results
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`OpenAI API Error: ${errorData.error?.message || 'Unknown error'}`);
                }

                const result = await response.json();
                const toolCall = result.choices[0].message.tool_calls[0];

                if (toolCall && toolCall.function && toolCall.function.arguments) {
                    const aiResult = JSON.parse(toolCall.function.arguments);
                    const aiCodes = aiResult.codes;

                    if (aiCodes && aiCodes.length > 0) {
                        let appliedCount = 0;
                        let skippedCount = 0;
                        
                        // Sort by confidence score
                        aiCodes.sort((a, b) => (b.confidence || 0) - (a.confidence || 0));
                        
                        for (const aiCode of aiCodes) {
                            const matchedCode = codebookDetails.find(c => c.openCode === aiCode.openCode);
                            
                            if (matchedCode) {
                                let applied = false;
                                
                                // First try exact match
                                if (textToCode.includes(aiCode.highlightedText)) {
                                    applyCode(
                                        aiCode.highlightedText, 
                                        matchedCode.openCode, 
                                        matchedCode.axialCode, 
                                        matchedCode.selectiveCode
                                    );
                                    applied = true;
                                    appliedCount++;
                                } else if (state.aiSettings.fuzzyMatch) {
                                    // Try fuzzy matching
                                    const fuzzyMatches = findFuzzyMatches(textToCode, aiCode.highlightedText);
                                    
                                    if (fuzzyMatches.length > 0) {
                                        // Apply the best match
                                        const bestMatch = fuzzyMatches[0];
                                        applyCode(
                                            bestMatch.text,
                                            matchedCode.openCode,
                                            matchedCode.axialCode,
                                            matchedCode.selectiveCode
                                        );
                                        applied = true;
                                        appliedCount++;
                                    }
                                }
                                
                                if (!applied) {
                                    skippedCount++;
                                    console.warn(`Could not find exact match for: "${aiCode.highlightedText}"`);
                                }
                            }
                        }
                        
                        showAiStatus(
                            `🧠 Smart AI coding complete! Applied ${appliedCount} codes${skippedCount > 0 ? ` (${skippedCount} skipped due to text mismatch)` : ''}. ${state.learningStats.totalExamples > 0 ? `Used ${state.learningStats.totalExamples} learning examples.` : ''}`,
                            'success'
                        );
                    } else {
                        showAiStatus("The AI could not find any relevant text to code for this prompt.", 'error');
                    }
                } else {
                    showAiStatus("The AI did not return any codes. Please try again.", 'error');
                }

            } catch (error) {
                console.error("AI Coder Error:", error);
                showAiStatus(`Error: ${error.message}`, 'error');
            } finally {
                toggleAiLoading(false);
            }
        }
        
        function toggleAiLoading(isLoading) {
            if (isLoading) {
                elements.aiCoderBtn.disabled = true;
                elements.aiCoderBtnText.textContent = 'Learning & Coding...';
                const spinner = document.createElement('span');
                spinner.className = 'loading-spinner';
                elements.aiCoderBtn.prepend(spinner);
            } else {
                elements.aiCoderBtn.disabled = false;
                elements.aiCoderBtnText.textContent = 'Smart AI Coder';
                const spinner = elements.aiCoderBtn.querySelector('.loading-spinner');
                if (spinner) spinner.remove();
            }
        }
        
        function showAiStatus(message, type = 'info') {
            elements.aiStatus.textContent = message;
            elements.aiStatus.className = 'ai-status show';
            if (type === 'error') elements.aiStatus.classList.add('error');
            else if (type === 'success') elements.aiStatus.classList.add('success');
            
            // Auto-hide after 7 seconds for success messages
            if (type === 'success') {
                setTimeout(() => {
                    elements.aiStatus.classList.remove('show');
                }, 7000);
            }
        }

        // --- PROGRESS & SAVING ---
        const updateProgressTable = (filterByPromptId = null) => {
            let dataToShow = [...state.codedData]; // Create a copy to sort
            
            if (filterByPromptId) {
                elements.progressTitle.textContent = `Codes for this Prompt (ID: ${filterByPromptId})`;
                dataToShow = dataToShow.filter(c => String(c.ID) === String(filterByPromptId));
                dataToShow.sort((a, b) => (a.startIndex || 0) - (b.startIndex || 0));
            } else {
                 elements.progressTitle.textContent = "All Coding Progress";
                 dataToShow.sort((a, b) => {
                    const idA = String(a.ID);
                    const idB = String(b.ID);
                    if (idA.localeCompare(idB) !== 0) return idA.localeCompare(idB);
                    return (a.startIndex || 0) - (b.startIndex || 0);
                });
            }

            elements.progressTableBody.innerHTML = '';
            if (state.codedData.length > 0) elements.saveProgressBtn.classList.remove('hidden');

            if (dataToShow.length > 0) {
                elements.noCodesMsg.classList.add('hidden');
                elements.progressTable.classList.remove('hidden');
                dataToShow.forEach(item => {
                    const row = elements.progressTableBody.insertRow();
                    row.insertCell(0).textContent = item.ID || '';
                    row.insertCell(1).textContent = item['Highlighted Text'] || '';
                    row.insertCell(2).textContent = item['Open Code'] || '';
                    row.insertCell(3).textContent = item['Axial Code'] || '';
                    row.insertCell(4).textContent = item['Selective Code'] || '';
                });
            } else {
                elements.noCodesMsg.classList.remove('hidden');
                elements.progressTable.classList.add('hidden');
            }
        };

        elements.saveProgressBtn.addEventListener('click', () => {
            // Create a sorted copy for saving
            const sortedData = [...state.codedData].sort((a, b) => {
                const idA = String(a.ID);
                const idB = String(b.ID);
                if (idA.localeCompare(idB) !== 0) return idA.localeCompare(idB);
                return (a.startIndex || 0) - (b.startIndex || 0);
            });
            // Exclude internal fields 'uuid' and 'startIndex' from the final save file
            const csvData = sortedData.map(({ uuid, startIndex, ...rest }) => rest);
            const csvString = Papa.unparse(csvData, { header: true });
            const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'coding_progress.csv';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        });
    });
    </script>
</body>
</html>