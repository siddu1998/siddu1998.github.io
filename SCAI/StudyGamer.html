<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StudyGamer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.3.0/marked.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
 <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

       body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    /* background: linear-gradient(135deg, #f6ad55 0%, #f97316 100%); */
    height: 100vh;
    display: flex;
}



   .main-content {
            width: 70%;
            display: flex;
            flex-direction: column;
        }


        
   .navbar input[type="text"] {
            padding: 8px;
            border: 2px solid #f6ad55;
            border-radius: 4px;
        }

        .navbar select {
            padding: 8px;
            border: 2px solid #f6ad55;
            border-radius: 4px;
        }

      
.sidebar {
    width: 30%;
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    padding: 24px;
    border-right: 1px solid rgba(255, 255, 255, 0.2);
    height: 100vh;
    overflow-y: auto;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
}

        
    .sidebar h1 {
        background: linear-gradient(135deg, #f6ad55, #f97316);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        font-size: 28px;
        font-weight: 700;
        margin-bottom: 8px;
    }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: rgba(255, 255, 255, 0.1);
        }

        .navbar {
            background: rgba(255, 255, 255, 0.9);
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

       
        .chat-window {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            background: white;
        }

        .message-input-area {
            background: rgba(255, 255, 255, 0.9);
            padding: 15px 20px;
            display: flex;
            align-items: center;
            position: sticky;
            bottom: 0;
            gap: 10px;
        }

        .form-container {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
        }

        .form-container h3 {
            color: #2d3748;
            margin-bottom: 15px;
            font-size: 18px;
        }

        .toggle-section {
            /* background: rgba(102, 126, 234, 0.1); */
            /* border: 2px solid #f6ad55; */
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .toggle-btn {
            background: linear-gradient(135deg, #f6ad55, #f97316);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            width: 100%;
        }

        .toggle-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(246, 173, 85, 0.4);
        }
.taxonomy-container {
            display: none;
            padding: 20px;
        }

        .taxonomy-container.active {
            display: block;
        }

        .taxonomy-category {
            margin-bottom: 30px;
            border: 1px solid #e1e8ed;
            border-radius: 8px;
            overflow: hidden;
        }

        .category-title {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            padding: 12px 16px;
            font-weight: 600;
            font-size: 16px;
        }

        .taxonomy-item {
            border-bottom: 1px solid #f0f0f0;
            padding: 16px;
            transition: background-color 0.2s ease;
        }

        .taxonomy-item:last-child {
            border-bottom: none;
        }

        .taxonomy-item:hover {
            background-color: #f8f9fa;
        }

        /* Fixed layout for checkbox and label */
        .taxonomy-item-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 8px;
        }

        .taxonomy-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: #667eea;
            flex-shrink: 0;
        }

        .taxonomy-item-name {
            font-weight: 600;
            font-size: 15px;
            color: #2c3e50;
            cursor: pointer;
            flex: 1;
        }

        .taxonomy-item-content {
            margin-left: 30px; /* Align with the text after checkbox */
        }

        .taxonomy-item-desc {
            color: #5a6c7d;
            font-size: 14px;
            line-height: 1.5;
            margin-bottom: 8px;
        }

        .taxonomy-item-example {
            background: #f8f9fa;
            border-left: 3px solid #667eea;
            padding: 10px 12px;
            font-size: 13px;
            color: #495057;
            border-radius: 0 4px 4px 0;
            font-style: italic;
        }

        .generate-prompt-btn {
             background: linear-gradient(135deg, #f6ad55, #f97316);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            margin-top: 15px;
            width: 100%;
            transition: all 0.3s ease;
        }

        .generate-prompt-btn:hover {
            transform: translateY(-2px);
             box-shadow: 0 4px 15px rgba(246, 173, 85, 0.4);
        }

        .generate-prompt-btn:disabled {
            background: #a0aec0;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .form-container label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #2d3748;
        }

        .form-container input,
        .form-container textarea,
        .form-container select {
            width: 100%;
            padding: 10px;
            border: 2px solid rgba(102, 126, 234, 0.3);
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        .form-container input:focus,
        .form-container textarea:focus,
        .form-container select:focus {
            outline: none;
            border-color: #667eea;
        }

        .form-container textarea {
            min-height: 100px;
            resize: vertical;
        }

        .form-container button[type="submit"] {
            background: linear-gradient(135deg, #f6ad55, #f97316);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            width: 100%;
            transition: all 0.3s ease;
        }

        .form-container button[type="submit"]:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(246, 173, 85, 0.4);
        }

        /* Chip System Styles */
        .chips-container {
            background: #f8f9fa;
            border: 2px dashed #dee2e6;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            min-height: 60px;
        }

        .chip {
            display: inline-flex;
            align-items: center;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 6px 12px;
            margin: 4px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 500;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .chip.gamified {
            background: linear-gradient(135deg, #f6ad55, #f97316);
        }

        .chip.syllabus {
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
        }

        .chip-remove {
            background: rgba(255,255,255,0.3);
            border: none;
            color: white;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            margin-left: 8px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .chip-remove:hover {
            background: rgba(255,255,255,0.5);
        }

        /* Split Instruction Fields */
        .instruction-fields {
            display: grid;
            gap: 15px;
            margin-bottom: 20px;
        }

        .field-group {
            background: rgba(255, 255, 255, 0.8);
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #e1e8ed;
        }

        .field-group h4 {
            margin: 0 0 10px 0;
            color: #2d3748;
            font-size: 14px;
            font-weight: 600;
        }

        .field-group textarea {
            min-height: 80px;
            margin-bottom: 0;
        }

        .file-upload-area {
            border: 2px dashed #667eea;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            background: rgba(102, 126, 234, 0.05);
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 15px;
        }

        .file-upload-area:hover {
            background: rgba(102, 126, 234, 0.1);
            border-color: #4c51bf;
        }

        .file-upload-area.dragover {
            background: rgba(102, 126, 234, 0.15);
            border-color: #4c51bf;
        }

        .file-upload-icon {
            font-size: 24px;
            margin-bottom: 10px;
            color: #667eea;
        }

        .file-upload-text {
            color: #4a5568;
            font-size: 14px;
        }

        .empty-state {
            color: #a0aec0;
            font-style: italic;
            text-align: center;
            padding: 20px;
        }

        /* Inline File Upload Styles */
        .inline-upload {
            position: relative;
            display: inline-block;
            margin-left: 10px;
        }

        .inline-upload-btn {
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .inline-upload-btn:hover {
            background: linear-gradient(135deg, #44a08d, #4ecdc4);
            transform: scale(1.05);
        }

        .inline-upload input[type="file"] {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .field-files {
            margin-top: 8px;
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .field-file-chip {
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 11px;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .field-file-chip .remove {
            background: rgba(255,255,255,0.3);
            border: none;
            color: white;
            border-radius: 50%;
            width: 14px;
            height: 14px;
            cursor: pointer;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Gamified Elements Dropdown Layout */
        .gamified-entry-container {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 12px;
            padding: 20px;
            border: 2px solid #f0f0f0;
            transition: all 0.3s ease;
            margin-top: 20px;
        }

        .gamified-entry-container:hover {
            border-color: #667eea;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.1);
        }

        .gamified-entry-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 15px;
            font-size: 16px;
            font-weight: 600;
            color: #2d3748;
        }

        .gamified-multiselect {
            width: 100%;
            padding: 12px;
            border: 2px solid #e1e8ed;
            border-radius: 8px;
            background: white;
            font-size: 14px;
            color: #2d3748;
            margin-bottom: 15px;
            min-height: 120px;
            max-height: 200px;
            overflow-y: auto;
        }

        .gamified-multiselect:focus {
            outline: none;
            border-color: #667eea;
        }

        .gamified-multiselect option {
            padding: 8px;
            font-size: 14px;
        }

        .gamified-text-entry {
            width: 100%;
            padding: 12px;
            border: 2px solid #e1e8ed;
            border-radius: 8px;
            background: white;
            font-size: 14px;
            color: #2d3748;
            transition: border-color 0.3s ease;
            resize: vertical;
            min-height: 60px;
        }

        .gamified-text-entry:focus {
            outline: none;
            border-color: #667eea;
        }

        /* Compact chips container */
        .chips-container.compact {
            min-height: 40px;
            padding: 10px;
        }

        .chips-container.compact .chip {
            font-size: 11px;
            padding: 4px 8px;
        }

      .user-message {
    background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
    padding: 16px 20px;
    border-radius: 20px 20px 8px 20px;
    max-width: 80%;
    margin: 8px 0 8px auto;
    word-wrap: break-word;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    animation: slideInRight 0.3s ease;
}

       .ai-message {
    background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
    padding: 16px 20px;
    border-radius: 20px 20px 20px 8px;
    max-width: 80%;
    margin: 8px auto 8px 0;
    word-wrap: break-word;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    animation: slideInLeft 0.3s ease;
}

        .upload-icon {
            background: #f6ad55;
            color: white;
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.3s ease;
        }

        .upload-icon:hover {
            background: #f97316;
            transform: scale(1.05);
        }

        #messageInput {
            flex: 1;
            padding: 12px;
            border: 2px solid rgba(102, 126, 234, 0.3);
            border-radius: 8px;
            font-size: 14px;
        }

        #sendMessage, #download-btn {
             background: #f6ad55;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        #sendMessage:hover, #download-btn:hover {
              background: #f97316;
            transform: translateY(-2px);
        }

        #sendMessage:disabled {
            background: #a0aec0;
            cursor: not-allowed;
            transform: none;
        }

        #result {
            margin-top: 15px;
            padding: 10px;
            border-radius: 8px;
            font-weight: 600;
        }

        .success {
            background: rgba(72, 187, 120, 0.1);
            color: #22543d;
            border: 1px solid rgba(72, 187, 120, 0.3);
        }

        .error {
            background: rgba(245, 101, 101, 0.1);
            color: #742a2a;
            border: 1px solid rgba(245, 101, 101, 0.3);
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <!-- Side Navigation Bar -->
    <div class="sidebar">
        <h1>StudyGamer</h1>
        
        <div class="form-container">
            <h3>Create a Custom GPT</h3>
            
            <!-- Quick Start Guide -->
        
            
            <form id="customGPTForm">
                <!-- Basic Information -->
                <label for="name">Bot Name:</label>
                <input type="text" id="name" name="name" required>
                
                <label for="created_by">Created By (Email ID):</label>
                <input type="text" id="created_by" name="created_by" required>

                <!-- Split Instruction Fields -->
                <div class="instruction-fields">
                    <div class="field-group">
                        <h4>🤖 AI Role & Persona <span style="color: #e53e3e;">*</span></h4>
                        <textarea id="aiRole" name="aiRole" placeholder="Define the AI's role, personality, and teaching approach (e.g., 'You are a friendly physics tutor who uses analogies and encourages questions')"></textarea>
                    </div>

                    <div class="field-group">
                        <h4>📚 Topics to Teach <span style="color: #e53e3e;">*</span>
                            <div class="inline-upload">
                                <button type="button" class="inline-upload-btn" onclick="document.getElementById('topicsToTeachUpload').click()">
                                    📁 Add Files
                                </button>
                                <input type="file" id="topicsToTeachUpload" multiple accept=".pdf,.doc,.docx,.txt,.md,.ppt,.pptx" style="display: none;">
                            </div>
                        </h4>
                        <textarea id="topicsToTeach" name="topicsToTeach" placeholder="List the specific topics, concepts, or skills students should learn (e.g., 'Newton's laws, momentum, energy conservation')"></textarea>
                        <div class="field-files" id="topicsToTeachFiles"></div>
                    </div>

                    <div class="field-group">
                        <h4>🚫 Topics to Avoid</h4>
                        <textarea id="topicsToAvoid" name="topicsToAvoid" placeholder="Specify any topics or approaches to avoid (e.g., 'Avoid advanced calculus, keep explanations at high school level')"></textarea>
                    </div>
                </div>

                <!-- Selected Gamified Elements Summary -->
                <div class="chips-container compact" id="gamifiedChipsContainer">
                    <div class="empty-state" id="gamifiedEmptyState">No gamified elements selected yet</div>
                </div>
                
                <!-- Gamified Elements Entry -->
                <div class="gamified-entry-container">
                    <div class="gamified-entry-header">
                        🎮 Gamified Elements (Optional)
                    </div>
                    
                    <select class="gamified-multiselect" id="gamifiedMultiselect" multiple onchange="updateGamifiedChips()">
                        <option value="points-scoring">Points & Scoring - Students earn points, XP, or coins for achievements</option>
                        <option value="quest-system">Quest System - Create missions and challenges with clear objectives</option>
                        <option value="character-interaction">Character Interaction - Introduce NPCs to guide and challenge students</option>
                        <option value="badge-collection">Badge Collection - Award badges for learning milestones</option>
                        <option value="health-lives">Health/Lives System - Visual indicators that decrease with wrong answers</option>
                        <option value="inventory-management">Inventory Management - Students collect tools and resources</option>
                        <option value="choice-based">Choice-Based Learning - Multiple paths based on student decisions</option>
                        <option value="randomizer">Randomizer Elements - Dice rolls and chance mechanics</option>
                        <option value="visual-aesthetics">Visual Aesthetics - Emojis, ASCII art, and symbols</option>
                        <option value="roleplay">Roleplay Scenarios - Students assume specific personas</option>
                        <option value="narrative-framing">Narrative Framing - Story contexts like space exploration</option>
                        <option value="multiplayer">Multiplayer Elements - Collaboration or competition between students</option>
                    </select>
                    
                    <textarea class="gamified-text-entry" id="gamifiedText" placeholder="Add custom details about your gamification approach (e.g., 'Students become math detectives earning badges for solving equations, with Professor Algebra as their guide. They collect clue cards and unlock new investigation tools.')" oninput="updateGamifiedChips()"></textarea>
                </div>

                    <div class="field-group">
                        <h4>⚖️ Game Constraints</h4>
                        <textarea id="gameConstraints" name="gameConstraints" placeholder="Define limitations or rules for the game mechanics (e.g., 'Each level must have exactly 5 questions, no time limits')"></textarea>
                    </div>

                    <div class="field-group">
                        <h4>🏆 Win/Lose Conditions</h4>
                        <textarea id="winLoseConditions" name="winLoseConditions" placeholder="Define how students win or lose in the game (e.g., 'Win by answering 8/10 questions correctly, lose if health reaches 0')"></textarea>
                    </div>

                    <div class="field-group">
                        <h4>💬 Interaction Tone & Style</h4>
                        <textarea id="interactionTone" name="interactionTone" placeholder="Set the communication style and tone (e.g., 'Encouraging and supportive, use emojis, ask follow-up questions')"></textarea>
                    </div>

                    <div class="field-group">
                        <h4>📝 Additional Instructions
                            <div class="inline-upload">
                                <button type="button" class="inline-upload-btn" onclick="document.getElementById('additionalInstructionsUpload').click()">
                                    📁 Add Files
                                </button>
                                <input type="file" id="additionalInstructionsUpload" multiple accept=".pdf,.doc,.docx,.txt,.md,.ppt,.pptx" style="display: none;">
                            </div>
                        </h4>
                        <textarea id="additionalInstructions" name="additionalInstructions" placeholder="Any other specific instructions or requirements for the AI"></textarea>
                        <div class="field-files" id="additionalInstructionsFiles"></div>
                    </div>
                </div>

                <!-- Hidden field to store the combined instructions -->
                <input type="hidden" id="instructions" name="instructions">

                <button type="button" id="previewInstructions" style="background: linear-gradient(135deg, #667eea, #764ba2); margin-bottom: 10px;">Preview Instructions</button>
                <button type="submit">Create Custom GPT</button>
            </form>
            <p id="result"></p>
            
            <!-- Preview Modal -->
            <div id="previewModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;">
                <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 30px; border-radius: 12px; max-width: 80%; max-height: 80%; overflow-y: auto; box-shadow: 0 20px 40px rgba(0,0,0,0.3);">
                    <h3 style="margin-top: 0; color: #2d3748;">Preview Combined Instructions</h3>
                    <pre id="previewContent" style="white-space: pre-wrap; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; line-height: 1.6; color: #4a5568; background: #f8f9fa; padding: 20px; border-radius: 8px; border: 1px solid #e1e8ed; max-height: 400px; overflow-y: auto;"></pre>
                    <div style="text-align: right; margin-top: 20px;">
                        <button onclick="closePreview()" style="background: #6c757d; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; margin-right: 10px;">Close</button>
                        <button onclick="copyToClipboard()" style="background: linear-gradient(135deg, #f6ad55, #f97316); color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer;">Copy Instructions</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Content Area -->
    <div class="main-content">
        <div class="navbar">
            <input type="text" id="studentId" placeholder="Enter Your Name/Alias">
            <div style="display: flex; align-items: center; gap: 10px;">
                <select id="gptSelection">
                    <option value="">Select Activity</option>
                </select>
                <button id="refreshPrompts" style="padding: 6px 10px; border: none; background: white; cursor: pointer; font-size: 16px;">
                    🔄
                </button>
            </div>
        </div>

         <div id="transcription" class="chat-window"></div>


        <div class="message-input-area">
            <input type="file" id="imageUpload" accept="image/*" style="display: none;">
            <label for="imageUpload" class="upload-icon">📷</label>
            
            <textarea id="messageInput" placeholder="Type your message here..."></textarea>
            <button id="sendMessage" disabled>Send</button>
            <button id="download-btn">Download Transcript</button>
        </div>
    </div>

    <script>

     
        // Update gamified chips display
        function updateGamifiedChips() {
            const container = document.getElementById('gamifiedChipsContainer');
            const emptyState = document.getElementById('gamifiedEmptyState');
            const multiselect = document.getElementById('gamifiedMultiselect');
            const textArea = document.getElementById('gamifiedText');
            
            // Clear existing chips
            const existingChips = container.querySelectorAll('.chip.gamified');
            existingChips.forEach(chip => chip.remove());
            
            const selectedElements = [];
            
            // Add selected gamification elements
            const selectedOptions = Array.from(multiselect.selectedOptions);
            selectedOptions.forEach(option => {
                const text = option.text.split(' - ')[0]; // Get just the main title
                selectedElements.push({
                    text: text,
                    value: option.value
                });
            });
            
            // Add custom text if provided
            if (textArea && textArea.value.trim() !== '') {
                selectedElements.push({
                    text: 'Custom Details',
                    isCustom: true,
                    content: textArea.value.trim()
                });
            }
            
            if (selectedElements.length === 0) {
                emptyState.style.display = 'block';
                return;
            }
            
            emptyState.style.display = 'none';
            
            selectedElements.forEach(element => {
                const chip = document.createElement('div');
                chip.className = 'chip gamified';
                
                if (element.isCustom) {
                    const preview = element.content.length > 50 ? 
                        element.content.substring(0, 50) + '...' : 
                        element.content;
                    chip.innerHTML = `
                        📝 ${preview}
                        <button class="chip-remove" onclick="removeCustomGamified()">×</button>
                    `;
                } else {
                    chip.innerHTML = `
                        🎮 ${element.text}
                        <button class="chip-remove" onclick="removeGamifiedOption('${element.value}')">×</button>
                    `;
                }
                container.appendChild(chip);
            });
        }

        // Remove gamified option
        function removeGamifiedOption(value) {
            const multiselect = document.getElementById('gamifiedMultiselect');
            const option = multiselect.querySelector(`option[value="${value}"]`);
            if (option) {
                option.selected = false;
                updateGamifiedChips();
            }
        }

        // Remove custom gamified text
        function removeCustomGamified() {
            const textArea = document.getElementById('gamifiedText');
            if (textArea) {
                textArea.value = '';
                updateGamifiedChips();
                
                // Auto-resize the textarea
                textArea.style.height = 'auto';
                textArea.style.height = textArea.scrollHeight + 'px';
            }
        }

        // Auto-resize textareas
        document.addEventListener('DOMContentLoaded', function() {
            document.querySelectorAll('.gamified-text-entry').forEach(textarea => {
                textarea.addEventListener('input', function() {
                    this.style.height = 'auto';
                    this.style.height = this.scrollHeight + 'px';
                });
            });
        });

        // Inline file management for each field
        const fieldFiles = {
            topicsToTeach: [],
            additionalInstructions: []
        };

        // Handle file uploads for topics to teach
        document.getElementById('topicsToTeachUpload').addEventListener('change', function(event) {
            handleFieldFileUpload(event, 'topicsToTeach');
        });

        // Handle file uploads for additional instructions
        document.getElementById('additionalInstructionsUpload').addEventListener('change', function(event) {
            handleFieldFileUpload(event, 'additionalInstructions');
        });

        function handleFieldFileUpload(event, fieldName) {
            const files = Array.from(event.target.files);
            files.forEach(file => addFieldFile(file, fieldName));
        }

        function addFieldFile(file, fieldName) {
            // Check if file already exists in this field
            if (fieldFiles[fieldName].some(f => f.name === file.name)) {
                alert('File already uploaded: ' + file.name);
                return;
            }

            fieldFiles[fieldName].push(file);
            updateFieldFiles(fieldName);
        }

        function updateFieldFiles(fieldName) {
            const container = document.getElementById(fieldName + 'Files');
            const files = fieldFiles[fieldName];
            
            container.innerHTML = '';
            
            files.forEach((file, index) => {
                const chip = document.createElement('div');
                chip.className = 'field-file-chip';
                chip.innerHTML = `
                    📄 ${file.name}
                    <button class="remove" onclick="removeFieldFile('${fieldName}', ${index})">×</button>
                `;
                container.appendChild(chip);
            });
        }

        function removeFieldFile(fieldName, index) {
            fieldFiles[fieldName].splice(index, 1);
            updateFieldFiles(fieldName);
        }

        // Preview functionality
        document.getElementById('previewInstructions').addEventListener('click', function() {
            const combinedInstructions = combineInstructions();
            if (!combinedInstructions) {
                showResult('Please provide some instructions first', 'error');
                return;
            }
            
            document.getElementById('previewContent').textContent = combinedInstructions;
            document.getElementById('previewModal').style.display = 'block';
        });

        function closePreview() {
            document.getElementById('previewModal').style.display = 'none';
        }

        function copyToClipboard() {
            const content = document.getElementById('previewContent').textContent;
            navigator.clipboard.writeText(content).then(() => {
                showResult('Instructions copied to clipboard!', 'success');
            }).catch(() => {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = content;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                showResult('Instructions copied to clipboard!', 'success');
            });
        }

        // Close modal when clicking outside
        document.getElementById('previewModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closePreview();
            }
        });


// Function to parse and populate instructions back into fields
function parseAndPopulateInstructions(instructions) {
    // For now, we'll put the enhanced instructions in the additional instructions field
    // and add a note about the gamification
    const additionalField = document.getElementById('additionalInstructions');
    const currentAdditional = additionalField.value.trim();
    
    let enhancedInstructions = "🎮 ENHANCED WITH GAMIFICATION:\n\n" + instructions;
    
    if (currentAdditional) {
        enhancedInstructions = currentAdditional + "\n\n" + enhancedInstructions;
    }
    
    additionalField.value = enhancedInstructions;
    
    // Auto-resize the textarea
    additionalField.style.height = 'auto';
    additionalField.style.height = additionalField.scrollHeight + 'px';
}

// Add a revert function
function revertInstructions(originalInstructions) {
    // Clear all fields first
    document.getElementById('aiRole').value = '';
    document.getElementById('topicsToTeach').value = '';
    document.getElementById('topicsToAvoid').value = '';
    document.getElementById('gameConstraints').value = '';
    document.getElementById('winLoseConditions').value = '';
    document.getElementById('interactionTone').value = '';
    document.getElementById('additionalInstructions').value = '';
    
    // Parse the original instructions and populate fields
    // This is a simplified approach - in a real implementation, you'd want more sophisticated parsing
    if (originalInstructions.includes('🤖 AI ROLE & PERSONA:')) {
        const sections = originalInstructions.split('🤖 AI ROLE & PERSONA:');
        if (sections[1]) {
            const aiRoleSection = sections[1].split('\n\n')[0];
            document.getElementById('aiRole').value = aiRoleSection.trim();
        }
    }
    
    // Auto-resize all textareas
    document.querySelectorAll('textarea').forEach(textarea => {
        textarea.style.height = 'auto';
        textarea.style.height = textarea.scrollHeight + 'px';
    });
    
    showResult('Reverted to original instructions', 'success');
}
        // Generate gamified prompt using OpenAI API
async function generateGamifiedPrompt(selectedElements, currentInstructions) {
    const openaiApiKey = localStorage.getItem('openaiKey');
    if (!openaiApiKey) {
        throw new Error('OpenAI API Key not found. Please wait for the key to load.');
    }

    // Create a more detailed prompt that emphasizes incorporating existing instructions
    const prompt = `You are an expert in gamification and educational design. Your task is to create a comprehensive gamified educational prompt that seamlessly blends existing instructions with new gamification elements.

    ${currentInstructions ? `**EXISTING INSTRUCTIONS TO PRESERVE AND ENHANCE:**
    ${currentInstructions}
    
    IMPORTANT: The above existing instructions contain the core educational approach and any specific narrative elements (characters, settings, themes) that MUST be preserved and enhanced in the gamified version. Do not replace these elements - integrate the gamification features around them.
    ` : ''}

    **SELECTED GAMIFICATION ELEMENTS TO INTEGRATE:**
    ${selectedElements.map(el => `
    • ${el.name}
    ${el.description}
    Note: The example provided (${el.example}) is just for reference. Be creative and design unique implementations that fit the educational context.
    `).join('\n')}

    **REQUIREMENTS FOR THE GAMIFIED PROMPT:**
    
    1. **Preserve Core Content**: If existing instructions mention specific characters, narratives, or educational approaches, these MUST be central to the gamified version.
    
    2. **Socratic Method Integration**: 
       - Design mechanics that encourage students to think critically rather than receive direct answers
       - Use questioning techniques that guide discovery
       - Create scenarios where wrong answers lead to learning opportunities, not just failure
       - When players just give answers, ask them for their process and how they reached that answer?
    3. **Cohesive Game Design**:
       - All gamification elements should work together as a unified system
       - Create smooth transitions between different game mechanics
       - Ensure the narrative flow isn't disrupted by game elements
    
    4. **Response Guidelines for the AI**:
       - Keep AI responses between 150-300 characters to maintain engagement
       - Focus on asking guiding questions rather than providing answers
       - Provide constructive feedback that encourages retry and learning
       - Use the game mechanics to scaffold learning progressively
    
    5. **Creative Implementation**:
       - Don't just copy the provided examples - create unique implementations
       - Design mechanics that specifically support the subject matter
       - Make failure fun and educational, not frustrating
    
    6. **Engagement Strategies**:
       - Create moments of surprise and delight
       - Build tension and release through game mechanics
       - Use rewards that feel meaningful to the learning journey
       - Design challenges that adapt to student performance

    Please create a detailed, engaging gamified educational prompt that transforms the learning experience into an adventure while maintaining educational rigor. The prompt should feel like a cohesive game where every element serves both fun and learning.`;

    const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${openaiApiKey}`
        },
        body: JSON.stringify({
            model: 'gpt-4o',
            messages: [
                {
                    role: 'system',
                    content: 'You are an expert educational game designer and prompt engineer. Create engaging, comprehensive gamified educational prompts that seamlessly blend existing educational content with game mechanics. Focus on creating cohesive experiences that use the Socratic method to develop critical thinking.'
                },
                {
                    role: 'user',
                    content: prompt
                }
            ],
            max_tokens: 2500,
            temperature: 0.8  // Slightly higher temperature for more creative responses
        })
    });

    if (!response.ok) {
        throw new Error('Failed to generate gamified prompt');
    }

    const data = await response.json();
    return data.choices[0].message.content.trim();
}
        // Show result message
        function showResult(message, type) {
            const resultElement = document.getElementById('result');
            resultElement.textContent = message;
            resultElement.className = type;
            
            setTimeout(() => {
                resultElement.textContent = '';
                resultElement.className = '';
            }, 5000);
        }

        // Auto-resize textarea functionality
        document.addEventListener("DOMContentLoaded", function () {
            const instructionsTextarea = document.getElementById("instructions");

            instructionsTextarea.addEventListener("input", function () {
                this.style.height = "auto";
                this.style.height = this.scrollHeight + "px";
            });

            // Auto-resize all textareas
            document.querySelectorAll("textarea").forEach(function (textarea) {
                textarea.addEventListener("input", function () {
                    this.style.height = "auto";
                    this.style.height = this.scrollHeight + "px";
                });
            });
        });

        // Refresh prompts functionality
        document.getElementById("refreshPrompts").addEventListener("click", function () {
            const dropdown = document.getElementById("gptSelection");
            
            dropdown.innerHTML = '<option value="">Select Activity</option>';

            $.get('https://guiidata-b6c968e6ed85.herokuapp.com/datapipeline/api/list_custom_gpts/', function (gpts) {
                gpts.forEach(function (gpt) {
                    dropdown.append(new Option(gpt.name, gpt.id));
                });
            });
        });

        // Image upload functionality
        document.getElementById("imageUpload").addEventListener("change", async function (event) {
            const file = event.target.files[0];

            if (file) {
                const reader = new FileReader();
                reader.onload = async function () {
                    const base64Image = reader.result.split(",")[1];
                    appendMessage("user-message", "📷 [Image Uploaded]");
                    chatHistory.push({ role: 'user', content: "Image Uploaded" });
                    analyzeImage(base64Image);
                };
                reader.readAsDataURL(file);
            }
        });

        async function analyzeImage(base64Image) {
            const openaiApiKey = localStorage.getItem('openaiKey');
            if (!openaiApiKey) {
                console.error("OpenAI API Key not found.");
                return;
            }

            const imageDataUrl = `data:image/jpeg;base64,${base64Image}`;
            appendMessage("user-message", null, imageDataUrl);

            chatHistory.push({
                role: "user",
                content: [
                    { type: "text", text: "Here is my image. analyze the image in the context of our chat, and pose a question or continue the conversation." },
                    { type: "image_url", image_url: { "url": imageDataUrl } }
                ]
            });

            const requestBody = {
                model: "gpt-4o",
                messages: chatHistory,
            };

            try {
                const response = await fetch("https://api.openai.com/v1/chat/completions", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": `Bearer ${openaiApiKey}`,
                    },
                    body: JSON.stringify(requestBody),
                });

                if (response.ok) {
                    const aiResponse = await response.json();
                    const responseText = aiResponse.choices[0].message.content;

                    appendMessage("ai-message", responseText);
                    chatHistory.push({ role: "assistant", content: responseText });

                } else {
                    console.error("Error processing image:", await response.text());
                }
            } catch (error) {
                console.error("Error:", error);
            }
        }

        function scrollToBottom() {
            const chatWindow = document.getElementById("transcription");
            chatWindow.scrollTop = chatWindow.scrollHeight;
        }

        function appendMessage(className, message, imageUrl = null) {
            const messageDiv = document.createElement("div");
            messageDiv.className = className;

            if (imageUrl) {
                const img = document.createElement("img");
                img.src = imageUrl;
                img.style.maxWidth = "100%";
                img.style.borderRadius = "10px";
                messageDiv.appendChild(img);
            } else {
                messageDiv.innerHTML = marked.parse(message);
            }

            document.getElementById("transcription").appendChild(messageDiv);
            storeData(message, className);
            scrollToBottom();
        }

        // Function to combine all instruction fields
        function combineInstructions() {
            const fields = {
                aiRole: document.getElementById("aiRole").value.trim(),
                topicsToTeach: document.getElementById("topicsToTeach").value.trim(),
                topicsToAvoid: document.getElementById("topicsToAvoid").value.trim(),
                gameConstraints: document.getElementById("gameConstraints").value.trim(),
                winLoseConditions: document.getElementById("winLoseConditions").value.trim(),
                interactionTone: document.getElementById("interactionTone").value.trim(),
                additionalInstructions: document.getElementById("additionalInstructions").value.trim()
            };

            let combinedInstructions = "";

            // Add gamified elements if any are selected
            const multiselect = document.getElementById('gamifiedMultiselect');
            const gamifiedText = document.getElementById('gamifiedText');
            const selectedOptions = Array.from(multiselect.selectedOptions);
            
            if (selectedOptions.length > 0 || (gamifiedText && gamifiedText.value.trim() !== '')) {
                combinedInstructions += "🎮 GAMIFICATION ELEMENTS:\n";
                
                selectedOptions.forEach(option => {
                    combinedInstructions += `• ${option.text}\n`;
                });
                
                if (gamifiedText && gamifiedText.value.trim() !== '') {
                    combinedInstructions += `• Custom Details: ${gamifiedText.value.trim()}\n`;
                }
                
                combinedInstructions += "\n";
            }

            // Add field-specific files
            Object.keys(fieldFiles).forEach(fieldName => {
                if (fieldFiles[fieldName].length > 0) {
                    const fieldTitle = fieldName === 'topicsToTeach' ? '📚 TOPICS TO TEACH FILES' : '📝 ADDITIONAL INSTRUCTION FILES';
                    combinedInstructions += `${fieldTitle}:\n`;
                    fieldFiles[fieldName].forEach(file => {
                        combinedInstructions += `• ${file.name}\n`;
                    });
                    combinedInstructions += "\n";
                }
            });

            // Add structured instruction fields
            if (fields.aiRole) {
                combinedInstructions += `🤖 AI ROLE & PERSONA:\n${fields.aiRole}\n\n`;
            }
            if (fields.topicsToTeach) {
                combinedInstructions += `📚 TOPICS TO TEACH:\n${fields.topicsToTeach}\n\n`;
            }
            if (fields.topicsToAvoid) {
                combinedInstructions += `🚫 TOPICS TO AVOID:\n${fields.topicsToAvoid}\n\n`;
            }
            if (fields.gameConstraints) {
                combinedInstructions += `⚖️ GAME CONSTRAINTS:\n${fields.gameConstraints}\n\n`;
            }
            if (fields.winLoseConditions) {
                combinedInstructions += `🏆 WIN/LOSE CONDITIONS:\n${fields.winLoseConditions}\n\n`;
            }
            if (fields.interactionTone) {
                combinedInstructions += `💬 INTERACTION TONE & STYLE:\n${fields.interactionTone}\n\n`;
            }
            if (fields.additionalInstructions) {
                combinedInstructions += `📝 ADDITIONAL INSTRUCTIONS:\n${fields.additionalInstructions}\n\n`;
            }

            return combinedInstructions.trim();
        }

        // Custom GPT Creator Logic
        const form = document.getElementById("customGPTForm");
        form.addEventListener("submit", async function (event) {
            event.preventDefault();

            const name = document.getElementById("name").value.trim();
            const createdBy = document.getElementById("created_by").value.trim();
            const university = "UCSC"
            const gptType = "GPT-4o";

            // Combine all instruction fields
            let instructionsToSend = combineInstructions();

            // Validate required fields
            const aiRole = document.getElementById("aiRole").value.trim();
            const topicsToTeach = document.getElementById("topicsToTeach").value.trim();
            
            if (!aiRole) {
                showResult("Please fill in the AI Role & Persona field", 'error');
                return;
            }
            
            if (!topicsToTeach) {
                showResult("Please fill in the Topics to Teach field", 'error');
                return;
            }

            // Validate that we have some instructions
            if (!instructionsToSend) {
                showResult("Please provide at least some instructions for the AI", 'error');
                return;
            }

            // Store the combined instructions in the hidden field
            document.getElementById("instructions").value = instructionsToSend;

            const formData = {
                name,
                created_by: createdBy,
                university,
                gpt_type: gptType,
                instructions: instructionsToSend
            };

            try {
                const response = await fetch("https://guiidata-b6c968e6ed85.herokuapp.com/datapipeline/api/create_new_gpt/", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                    },
                    body: JSON.stringify(formData)
                });

                if (response.ok) {
                    const result = await response.json();
                    showResult("Custom GPT created successfully with ID: " + result.id, 'success');
                } else {
                    const errorText = await response.text();
                    showResult("Error: " + errorText, 'error');
                }
            } catch (error) {
                showResult("Error: " + error.message, 'error');
            }
        });

        function storeData(content, sentBy) {
            const studentId = $('#studentId').val();
            const data = {
                session_id: localStorage.getItem('sessionID'),
                student_id: studentId,
                sent_by: sentBy,
                content: content,
                gpt_used: localStorage.getItem('selectedGPT')
            };

            $.ajax({
                type: 'POST',
                url: 'https://guiidata-b6c968e6ed85.herokuapp.com/datapipeline/api/message/',
                contentType: 'application/json',
                data: JSON.stringify(data),
                success: function (response) {
                    console.log('Message stored:', response);
                },
                error: function (xhr, status, error) {
                    console.error('Error storing message:', error);
                }
            });
        }

        // StudyHelper Logic
        let chatHistory = [];
        $(document).ready(function () {
            var uniqueID = 'id_' + Math.random().toString(36).substr(2, 9);
            localStorage.setItem('sessionID', uniqueID);

            $.get('https://guiidata-b6c968e6ed85.herokuapp.com/datapipeline/api/list_custom_gpts/', function (gpts) {
                gpts.forEach(function (gpt) {
                    $('#existingPrompts').append(new Option(gpt.name, gpt.instructions));
                });
            });

            // Fetch API key and GPT options
            $.get('https://guiidata-b6c968e6ed85.herokuapp.com/datapipeline/api/getOAI/', function (data) {
                localStorage.setItem('openaiKey', data.key);
                console.log('Key set');
            });

            $.get('https://guiidata-b6c968e6ed85.herokuapp.com/datapipeline/api/list_custom_gpts/', function (gpts) {
                gpts.forEach(function (gpt) {
                    $('#gptSelection').append(new Option(gpt.name, gpt.id));
                });
            });

            // Disable inputs until a valid ID is entered
            $('#gptSelection, #messageInput, #sendMessage, #download-btn').prop('disabled', true);

            // Enable inputs after valid ID is entered
            $('#studentId').on('input', function () {
                const studentId = $(this).val().trim();
                const isValidId = studentId.length > 0;
                $('#gptSelection, #messageInput, #sendMessage, #download-btn').prop('disabled', !isValidId);
            });

            $('#gptSelection').on('change', function () {
                const selectedGptId = $(this).val();
                if (!selectedGptId) return;

                // Clear chat history and chat window
                chatHistory = [];
                $('#transcription').empty();

                $.get('https://guiidata-b6c968e6ed85.herokuapp.com/datapipeline/api/list_custom_gpts/', function (gpts) {
                    const selectedGpt = gpts.find(g => g.id == selectedGptId);
                    if (selectedGpt) {
                        localStorage.setItem('selectedGPT', selectedGpt.name);
                        
                        // Add only the new GPT system message
                        chatHistory.push({ role: 'system', content: selectedGpt.instructions });

                        // Generate a new introductory message for the selected GPT
                        generateIntroductoryMessage(selectedGpt.instructions);
                    }
                });
            });

            // Send Message
            $('#sendMessage').on('click', function () {
                var message = $('#messageInput').val().trim();
                if (message) {
                    chatHistory.push({ role: 'user', content: message });
                    appendMessage('user-message', message);
                    $('#messageInput').val('');
                    getAIresponse(message);
                }
            });

            $('#messageInput').on('keypress', function (e) {
                if (e.which == 13) {
                    $('#sendMessage').click();
                }
            });

            function generateIntroductoryMessage(instructions) {
                $.ajax({
                    type: 'POST',
                    url: 'https://api.openai.com/v1/chat/completions',
                    data: JSON.stringify({
                        model: "gpt-4o",
                        messages: [{
                            role: 'system',
                            content: instructions + ": For the above instructions generate an introductory message, welcoming the student and setting the context of this session, keep it short and neat."
                        }]
                    }),
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + localStorage.getItem('openaiKey')
                    },
                    success: function (aiResponse) {
                        let introMessage = aiResponse.choices[0].message.content.trim();
                        
                        // Append new introductory message as AI message
                        appendMessage('ai-message', introMessage);

                        // Reset chat history after introductory message
                        chatHistory.push({ role: 'system', content: introMessage });
                    }
                });
            }

            function getAIresponse(message) {
                const maxCharacterLimit = 6000;
                let totalCharacterLength = chatHistory.slice(1).reduce((acc, msg) => acc + msg.content.length, 0);

                while (totalCharacterLength > maxCharacterLimit) {
                    chatHistory.splice(1, 1);
                    totalCharacterLength = chatHistory.slice(1).reduce((acc, msg) => acc + msg.content.length, 0);
                }

                $.ajax({
                    type: 'POST',
                    url: 'https://api.openai.com/v1/chat/completions',
                    data: JSON.stringify({
                        model: "gpt-4o",
                        messages: chatHistory
                    }),
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + localStorage.getItem('openaiKey')
                    },
                    success: function (aiResponse) {
                        // Get the AI's response text
                        let responseText = aiResponse.choices[0].message.content.trim();
                        
                        // Display the AI's response immediately
                        appendMessage('ai-message', responseText);
                        
                        // Add the response to chat history
                        chatHistory.push({ role: 'assistant', content: responseText });
                        
                        // Analyze if an image would be helpful for this response
                        if($('#studentId').val() == 'Sai'){
                            analyzeForImageGeneration(message, responseText);
                        }
                    }
                });
            }

            function analyzeForImageGeneration(userMessage, aiResponse) {
                const openaiApiKey = localStorage.getItem('openaiKey');
                
                // Create an analysis prompt to decide if an image would be helpful
                const analysisPrompt = [
                    {
                        role: 'system',
                        content: `You are an educational AI that analyzes conversations to determine if generating an image would enhance learning. 
                                Respond with a JSON object:
                                If an image WOULD be helpful: {"generate": true, "prompt": "detailed image prompt here"}
                                If an image would NOT be helpful: {"generate": false}
                                Consider diagrams, visual examples, and complex concepts that benefit from visualization.
                                DO NOT suggest generating images for inappropriate content, sensitive topics, or where text explanation is sufficient.`
                    },
                    {
                        role: 'user',
                        content: `User message: "${userMessage}"
                                AI response: "${aiResponse}"
                                
                                Would an image enhance this educational interaction? If so, create a detailed image prompt. Only agree to generate an image if its an NPC discussion or world setting in the game`
                    }
                ];
                
                $.ajax({
                    type: 'POST',
                    url: 'https://api.openai.com/v1/chat/completions',
                    data: JSON.stringify({
                        model: "gpt-4o",
                        messages: analysisPrompt,
                        response_format: { type: "json_object" }
                    }),
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + openaiApiKey
                    },
                    success: function (analysisResponse) {
                        try {
                            // Parse the JSON response
                            const analysis = JSON.parse(analysisResponse.choices[0].message.content);
                            
                            // If an image would be helpful, generate it
                            if (analysis.generate && analysis.prompt) {
                                generateAndDisplayImage(analysis.prompt);
                            }
                        } catch (error) {
                            console.error("Error parsing analysis response:", error);
                        }
                    },
                    error: function(xhr, status, error) {
                        console.error("Error during analysis:", error);
                    }
                });
            }

            // Function to generate an image and display it in the chat
            function generateAndDisplayImage(imagePrompt) {
                const openaiApiKey = localStorage.getItem('openaiKey');
                
                // Show a loading message
                const loadingMessageId = "img-loading-" + Date.now();
                appendMessage('ai-message', `<div id="${loadingMessageId}">Generating a helpful visual...</div>`);
                
                // Call the DALL-E API to generate the image
                fetch("https://api.openai.com/v1/images/generations", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": `Bearer ${openaiApiKey}`,
                    },
                    body: JSON.stringify({
                        model: "dall-e-3",
                        prompt: imagePrompt,
                        n: 1,
                        size: "1024x1024"
                    }),
                })
                .then(response => response.json())
                .then(data => {
                    if (data.data && data.data[0] && data.data[0].url) {
                        const imageUrl = data.data[0].url;
                        
                        // Replace the loading message with the image
                        const loadingElement = document.getElementById(loadingMessageId);
                        if (loadingElement) {
                            loadingElement.innerHTML = `
                                <div>
                                    <img src="${imageUrl}" alt="Generated visual aid" style="max-width: 100%; border-radius: 10px; margin: 10px 0;">
                                </div>`;
                        } else {
                            // If the loading element is no longer there, append a new message with the image
                            appendMessage('ai-message', `<img src="${imageUrl}" alt="Generated visual aid" style="max-width: 100%; border-radius: 10px; margin: 10px 0;">`);
                        }
                    } else {
                        console.error("Image generation failed:", data);
                        // Remove the loading message if generation failed
                        const loadingElement = document.getElementById(loadingMessageId);
                        if (loadingElement) {
                            loadingElement.remove();
                        }
                    }
                })
                .catch(error => {
                    console.error("Error generating image:", error);
                    // Remove the loading message if there was an error
                    const loadingElement = document.getElementById(loadingMessageId);
                    if (loadingElement) {
                        loadingElement.remove();
                    }
                });
            }

            // Download Transcript Functionality
            document.getElementById('download-btn').addEventListener('click', function () {
                var transcriptionContent = document.getElementById('transcription').innerHTML;

                var css = `
                body { font-family: 'Arial', sans-serif; background: #f4f4f4; color: #333; }
                .user-message { background-color: #c8e6c9; align-self: flex-end; margin-left: auto; word-wrap: break-word; }
                .ai-message { background-color: #bbdefb; align-self: flex-start; margin-right: auto; word-wrap: break-word; }`;

                var htmlContentWithCSS = `<html><head><style>${css}</style></head><body>${transcriptionContent}</body></html>`;

                var blob = new Blob([htmlContentWithCSS], {
                    type: 'text/html'
                });
                var tempLink = document.createElement('a');
                tempLink.download = 'transcript.html';
                tempLink.href = window.URL.createObjectURL(blob);

                // Temporarily add link to the body and trigger the download
                document.body.appendChild(tempLink);
                tempLink.click();

                // Clean up by removing the temporary link
                document.body.removeChild(tempLink);
            });
        });
    </script>
</body>
</html>