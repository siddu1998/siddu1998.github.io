<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prompt Structure Analysis Dashboard</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #ffffff;
            color: #333;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 10px;
            margin-bottom: 30px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }
        
        .dashboard-grid {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .sidebar {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        
        .sidebar h2 {
            font-size: 1.3em;
            margin-bottom: 20px;
            color: #667eea;
        }
        
        .search-box {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin-bottom: 20px;
            font-size: 14px;
        }
        
        .filter-section {
            margin-bottom: 25px;
        }
        
        .filter-section h3 {
            font-size: 1.1em;
            margin-bottom: 10px;
            color: #555;
        }
        
        .element-filters {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #e0e0e0;
            border-radius: 5px;
            padding: 10px;
            background: white;
        }
        
        .element-filter {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 14px;
        }
        
        .element-filter input[type="checkbox"] {
            margin-right: 8px;
        }
        
        .reset-filters {
            background: #ff6b35;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            width: 100%;
            font-size: 16px;
            font-weight: 500;
            transition: background 0.3s;
        }
        
        .reset-filters:hover {
            background: #ff5722;
        }
        
        .main-content {
            background: white;
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        
        .prompt-list {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 30px;
        }
        
        .prompt-list h2 {
            font-size: 1.5em;
            margin-bottom: 20px;
            color: #667eea;
        }
        
        .prompt-items {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 10px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .prompt-item {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            cursor: pointer;
            text-align: center;
            font-weight: 600;
            transition: all 0.3s;
            color: #667eea;
        }
        
        .prompt-item:hover {
            border-color: #667eea;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(102, 126, 234, 0.2);
        }
        
        .prompt-item.selected {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: #667eea;
        }
        
        .prompt-details {
            background: white;
            border-radius: 10px;
            padding: 30px;
            margin-bottom: 30px;
            border: 1px solid #e0e0e0;
        }
        
        .prompt-details h2 {
            font-size: 1.8em;
            margin-bottom: 20px;
            color: #667eea;
        }
        
        .detail-section {
            margin-bottom: 30px;
        }
        
        .detail-section h3 {
            font-size: 1.3em;
            margin-bottom: 15px;
            color: #555;
        }
        
        .structure-list {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .structure-item {
            background: white;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 5px;
            border-left: 4px solid #667eea;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        
        .description-text {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            line-height: 1.8;
            white-space: pre-wrap;
        }
        
        .element-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }
        
        .element-tag {
            background: linear-gradient(135deg, #667eea20 0%, #764ba220 100%);
            color: #667eea;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 14px;
            border: 1px solid #667eea40;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .element-tag:hover {
            background: linear-gradient(135deg, #667eea30 0%, #764ba230 100%);
            transform: scale(1.05);
        }
        
        .frequency-chart {
            background: white;
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            margin-bottom: 30px;
        }
        
        .frequency-chart h2 {
            font-size: 1.5em;
            margin-bottom: 20px;
            color: #667eea;
        }
        
        .chart-container {
            position: relative;
            height: 400px;
        }
        
        .network-graph {
            background: white;
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            margin-bottom: 30px;
        }
        
        .network-graph h2 {
            font-size: 1.5em;
            margin-bottom: 20px;
            color: #667eea;
        }
        
        .graph-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            align-items: center;
        }
        
        .graph-control-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }
        
        .graph-control-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }
        
        .graph-container {
            position: relative;
            height: 600px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background: radial-gradient(circle at center, #fafbff 0%, #f0f2ff 100%);
        }
        
        .no-selection {
            text-align: center;
            padding: 60px;
            color: #999;
        }
        
        .no-selection h3 {
            font-size: 1.5em;
            margin-bottom: 10px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            background: linear-gradient(135deg, #667eea10 0%, #764ba210 100%);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid #667eea20;
        }
        
        .stat-card h4 {
            color: #667eea;
            font-size: 0.9em;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .stat-card .stat-value {
            font-size: 2.5em;
            font-weight: 700;
            color: #764ba2;
        }
        
        .node-text {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 11px;
            font-weight: 600;
            fill: white;
            text-anchor: middle;
            dominant-baseline: middle;
            pointer-events: none;
        }
        
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Prompt Structure Analysis Dashboard</h1>
            <p>Explore analyses of gamified prompts, their design elements, and interaction structures.</p>
        </div>
        
        <div class="dashboard-grid">
            <aside class="sidebar">
                <h2>Controls & Filters</h2>
                <p style="margin-bottom: 20px; color: #666; font-size: 14px;">
                    Use the controls below to search for prompts or filter them by the
                    game and pedagogical elements they contain. Click on an element
                    in the chart or a tag in the details view to filter by that element.
                </p>
                
                <div class="filter-section">
                    <h3>Search by Prompt Identifier</h3>
                    <input type="text" class="search-box" id="searchBox" placeholder="Enter keywords...">
                </div>
                
                <div class="filter-section">
                    <h3>Filter by Elements</h3>
                    <div class="element-filters" id="elementFilters">
                        <!-- Filters will be populated dynamically -->
                    </div>
                </div>
                
                <button class="reset-filters" onclick="resetFilters()">Reset All Filters</button>
            </aside>
            
            <main class="main-content">
                <div class="stats-grid">
                    <div class="stat-card">
                        <h4>Total Prompts</h4>
                        <div class="stat-value" id="totalPrompts">0</div>
                    </div>
                    <div class="stat-card">
                        <h4>Unique Elements</h4>
                        <div class="stat-value" id="uniqueElements">0</div>
                    </div>
                    <div class="stat-card">
                        <h4>Filtered Prompts</h4>
                        <div class="stat-value" id="filteredPrompts">0</div>
                    </div>
                    <div class="stat-card">
                        <h4>Selected Elements</h4>
                        <div class="stat-value" id="selectedElements">0</div>
                    </div>
                </div>
                
                <div class="network-graph">
                    <h2>Element Network Visualization</h2>
                    <p style="margin-bottom: 20px; color: #666;">
                        This network shows all identified elements and their connections across prompts. 
                        Select a prompt to highlight only its elements and connections. Hover over nodes for details.
                    </p>
                    <div class="graph-controls">
                        <button class="graph-control-btn" onclick="resetGraphView()">Reset View</button>
                        <button class="graph-control-btn" onclick="centerGraph()">Center Graph</button>
                        <span style="color: #666; font-size: 14px; margin-left: 10px;">
                            Drag nodes to reposition • Scroll to zoom • Click nodes to filter
                        </span>
                    </div>
                    <div class="graph-container" id="graphContainer">
                        <svg id="networkGraph"></svg>
                    </div>
                </div>
                
                <div class="frequency-chart">
                    <h2>Element Frequency Overview</h2>
                    <p style="margin-bottom: 20px; color: #666;">
                        This chart shows how many prompts include each identified game design or pedagogical element. 
                        Click on a bar to filter the prompt list by that element.
                    </p>
                    <div class="chart-container">
                        <canvas id="frequencyChart"></canvas>
                    </div>
                </div>
                
                <div class="prompt-list">
                    <h2>Prompt List</h2>
                    <p style="margin-bottom: 20px; color: #666;">
                        Below is a list of analyzed prompts. Click on a prompt to see its detailed analysis. 
                        The list updates based on your active search and filters.
                    </p>
                    <div class="prompt-items" id="promptItems">
                        <!-- Prompt items will be populated dynamically -->
                    </div>
                </div>
                
                <div id="promptDetails">
                    <div class="no-selection">
                        <h3>No Prompt Selected</h3>
                        <p>Please select a prompt from the list above to view its detailed analysis.</p>
                    </div>
                </div>
            </main>
        </div>
    </div>
    
    <div class="tooltip" id="tooltip"></div>
    
    <script>
        let promptData = [];
        let elementFrequencies = {};
        let selectedFilters = new Set();
        let frequencyChart = null;
        let selectedPromptId = null;
        let networkGraph = null;
        let graphData = { nodes: [], links: [] };
        let simulation = null;
        
        // Load and parse the CSV data
        async function loadData() {
            try {
                // Check if we're in Claude.ai environment
                if (window.fs && window.fs.readFile) {
                    const csvText = await window.fs.readFile('Prompts Database  Prompt Structures.csv', { encoding: 'utf8' });
                    processCSVData(csvText);
                } else {
                    // Show file upload interface
                    showFileUploadInterface();
                }
            } catch (error) {
                console.error('Error loading data:', error);
                showFileUploadInterface();
            }
        }
        
        function processCSVData(csvText) {
            const parsed = Papa.parse(csvText, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true
            });
            
            promptData = parsed.data;
            calculateElementFrequencies();
            buildNetworkData();
            updateStats();
            populateElementFilters();
            populatePromptList();
            createFrequencyChart();
            createNetworkGraph();
            
            // Hide upload interface if it exists
            const uploadInterface = document.getElementById('uploadInterface');
            if (uploadInterface) {
                uploadInterface.style.display = 'none';
            }
        }
        
        function showFileUploadInterface() {
            const mainContent = document.querySelector('.main-content');
            const uploadHTML = `
                <div id="uploadInterface" style="text-align: center; padding: 40px; background: #f8f9fa; border-radius: 10px; margin-bottom: 30px;">
                    <h2 style="color: #667eea; margin-bottom: 20px;">Upload CSV File</h2>
                    <p style="margin-bottom: 20px; color: #666;">Please upload the "Prompts Database Prompt Structures.csv" file to begin analysis.</p>
                    <input type="file" id="csvFileInput" accept=".csv" style="display: none;">
                    <button onclick="document.getElementById('csvFileInput').click()" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; padding: 12px 30px; border-radius: 5px; cursor: pointer; font-size: 16px;">
                        Choose CSV File
                    </button>
                </div>
            `;
            
            mainContent.insertAdjacentHTML('afterbegin', uploadHTML);
            
            document.getElementById('csvFileInput').addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        processCSVData(event.target.result);
                    };
                    reader.readAsText(file);
                }
            });
        }
        
        function calculateElementFrequencies() {
            elementFrequencies = {};
            
            promptData.forEach(row => {
                if (row['List of all codes in prompt']) {
                    const codes = smartSplitCodes(row['List of all codes in prompt']);
                    codes.forEach(code => {
                        if (code && !code.includes(':')) {
                            elementFrequencies[code] = (elementFrequencies[code] || 0) + 1;
                        }
                    });
                }
            });
        }
        
        function buildNetworkData() {
            const nodes = new Map();
            const links = new Map();
            
            // Create nodes for all elements
            Object.keys(elementFrequencies).forEach(element => {
                if (!nodes.has(element)) {
                    nodes.set(element, {
                        id: element,
                        name: element,
                        frequency: elementFrequencies[element],
                        size: Math.max(8, Math.min(30, elementFrequencies[element] * 2))
                    });
                }
            });
            
            // Create links based on co-occurrence in prompts
            promptData.forEach(prompt => {
                if (prompt['List of all codes in prompt']) {
                    const codes = smartSplitCodes(prompt['List of all codes in prompt'])
                        .filter(code => code && !code.includes(':'));
                    
                    // Create links between all pairs of codes in this prompt
                    for (let i = 0; i < codes.length; i++) {
                        for (let j = i + 1; j < codes.length; j++) {
                            const source = codes[i];
                            const target = codes[j];
                            const linkId = `${source}-${target}`;
                            const reverseLinkId = `${target}-${source}`;
                            
                            if (!links.has(linkId) && !links.has(reverseLinkId)) {
                                links.set(linkId, {
                                    source: source,
                                    target: target,
                                    weight: 1,
                                    prompts: [prompt['Unique ID']]
                                });
                            } else {
                                const existingLink = links.get(linkId) || links.get(reverseLinkId);
                                existingLink.weight++;
                                existingLink.prompts.push(prompt['Unique ID']);
                            }
                        }
                    }
                }
            });
            
            graphData = {
                nodes: Array.from(nodes.values()),
                links: Array.from(links.values())
            };
        }
        
        function createNetworkGraph() {
            const container = d3.select('#graphContainer');
            const svg = d3.select('#networkGraph');
            
            const containerRect = document.getElementById('graphContainer').getBoundingClientRect();
            const width = containerRect.width;
            const height = containerRect.height;
            
            svg.attr('width', width).attr('height', height);
            
            // Create gradient definitions
            const defs = svg.append('defs');
            
            const gradient = defs.append('linearGradient')
                .attr('id', 'nodeGradient');
            
            gradient.append('stop')
                .attr('offset', '0%')
                .attr('stop-color', '#667eea');
            
            gradient.append('stop')
                .attr('offset', '100%')
                .attr('stop-color', '#764ba2');
            
            const highlightGradient = defs.append('linearGradient')
                .attr('id', 'highlightGradient');
            
            highlightGradient.append('stop')
                .attr('offset', '0%')
                .attr('stop-color', '#ff6b35');
            
            highlightGradient.append('stop')
                .attr('offset', '100%')
                .attr('stop-color', '#ff8a50');
            
            // Create zoom behavior
            const zoom = d3.zoom()
                .scaleExtent([0.1, 4])
                .on('zoom', (event) => {
                    g.attr('transform', event.transform);
                });
            
            svg.call(zoom);
            
            const g = svg.append('g');
            
            // Create simulation
            simulation = d3.forceSimulation(graphData.nodes)
                .force('link', d3.forceLink(graphData.links).id(d => d.id).distance(d => Math.max(50, 100 - d.weight * 5)))
                .force('charge', d3.forceManyBody().strength(-300))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(d => d.size + 5));
            
            // Create links
            const link = g.append('g')
                .selectAll('line')
                .data(graphData.links)
                .enter().append('line')
                .attr('stroke', '#ddd')
                .attr('stroke-width', d => Math.max(1, d.weight / 2))
                .attr('opacity', 0.6);
            
            // Create nodes
            const node = g.append('g')
                .selectAll('g')
                .data(graphData.nodes)
                .enter().append('g')
                .attr('class', 'node')
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));
            
            // Add circles to nodes
            node.append('circle')
                .attr('r', d => d.size)
                .attr('fill', 'url(#nodeGradient)')
                .attr('stroke', '#fff')
                .attr('stroke-width', 2)
                .style('filter', 'drop-shadow(0 2px 4px rgba(0,0,0,0.2))')
                .on('click', function(event, d) {
                    event.stopPropagation();
                    toggleFilter(d.id);
                    updateNetworkHighlight();
                })
                .on('mouseover', function(event, d) {
                    showTooltip(event, d);
                })
                .on('mouseout', hideTooltip);
            
            // Add text to nodes
            node.append('text')
                .attr('class', 'node-text')
                .text(d => {
                    // Truncate long text
                    if (d.name.length > 12) {
                        return d.name.substring(0, 10) + '...';
                    }
                    return d.name;
                })
                .attr('dy', '.35em');
            
            // Update positions on simulation tick
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);
                
                node
                    .attr('transform', d => `translate(${d.x},${d.y})`);
            });
            
            // Store references for later use
            networkGraph = { svg, g, node, link, zoom };
            
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }
            
            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }
            
            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
        }
        
        function updateNetworkHighlight() {
            if (!networkGraph || !selectedPromptId) {
                resetNetworkHighlight();
                return;
            }
            
            const selectedPrompt = promptData.find(p => p['Unique ID'] === selectedPromptId);
            if (!selectedPrompt || !selectedPrompt['List of all codes in prompt']) {
                resetNetworkHighlight();
                return;
            }
            
            const promptCodes = smartSplitCodes(selectedPrompt['List of all codes in prompt'])
                .filter(code => code && !code.includes(':'));
            
            // Highlight nodes
            networkGraph.node.select('circle')
                .attr('fill', d => promptCodes.includes(d.id) ? 'url(#highlightGradient)' : 'url(#nodeGradient)')
                .attr('opacity', d => promptCodes.includes(d.id) ? 1 : 0.3)
                .attr('r', d => promptCodes.includes(d.id) ? d.size * 1.2 : d.size);
            
            networkGraph.node.select('text')
                .attr('opacity', d => promptCodes.includes(d.id) ? 1 : 0.3);
            
            // Highlight links
            networkGraph.link
                .attr('stroke', d => {
                    const sourceInPrompt = promptCodes.includes(d.source.id || d.source);
                    const targetInPrompt = promptCodes.includes(d.target.id || d.target);
                    return (sourceInPrompt && targetInPrompt) ? '#ff6b35' : '#ddd';
                })
                .attr('opacity', d => {
                    const sourceInPrompt = promptCodes.includes(d.source.id || d.source);
                    const targetInPrompt = promptCodes.includes(d.target.id || d.target);
                    return (sourceInPrompt && targetInPrompt) ? 0.8 : 0.2;
                })
                .attr('stroke-width', d => {
                    const sourceInPrompt = promptCodes.includes(d.source.id || d.source);
                    const targetInPrompt = promptCodes.includes(d.target.id || d.target);
                    return (sourceInPrompt && targetInPrompt) ? Math.max(2, d.weight / 2) : Math.max(1, d.weight / 2);
                });
        }
        
        function resetNetworkHighlight() {
            if (!networkGraph) return;
            
            networkGraph.node.select('circle')
                .attr('fill', 'url(#nodeGradient)')
                .attr('opacity', 1)
                .attr('r', d => d.size);
            
            networkGraph.node.select('text')
                .attr('opacity', 1);
            
            networkGraph.link
                .attr('stroke', '#ddd')
                .attr('opacity', 0.6)
                .attr('stroke-width', d => Math.max(1, d.weight / 2));
        }
        
        function resetGraphView() {
            if (!networkGraph) return;
            
            const containerRect = document.getElementById('graphContainer').getBoundingClientRect();
            const width = containerRect.width;
            const height = containerRect.height;
            
            networkGraph.svg.transition()
                .duration(750)
                .call(networkGraph.zoom.transform, d3.zoomIdentity);
        }
        
        function centerGraph() {
            if (!networkGraph || !simulation) return;
            
            simulation.alpha(0.3).restart();
        }
        
        function showTooltip(event, d) {
            const tooltip = document.getElementById('tooltip');
            tooltip.innerHTML = `
                <strong>${d.name}</strong><br>
                Frequency: ${d.frequency} prompts<br>
                Click to filter by this element
            `;
            tooltip.style.left = (event.pageX + 10) + 'px';
            tooltip.style.top = (event.pageY - 10) + 'px';
            tooltip.style.opacity = 1;
        }
        
        function hideTooltip() {
            const tooltip = document.getElementById('tooltip');
            tooltip.style.opacity = 0;
        }
        
        function smartSplitCodes(codeString) {
            const codes = [];
            let currentCode = '';
            let inParentheses = 0;
            
            for (let i = 0; i < codeString.length; i++) {
                const char = codeString[i];
                
                if (char === '(') {
                    inParentheses++;
                } else if (char === ')') {
                    inParentheses--;
                }
                
                if (char === ',' && inParentheses === 0) {
                    // We're at a comma outside of parentheses, so split here
                    if (currentCode.trim()) {
                        codes.push(currentCode.trim());
                    }
                    currentCode = '';
                } else {
                    currentCode += char;
                }
            }
            
            // Don't forget the last code
            if (currentCode.trim()) {
                codes.push(currentCode.trim());
            }
            
            return codes;
        }
        
        function updateStats() {
            document.getElementById('totalPrompts').textContent = promptData.length;
            document.getElementById('uniqueElements').textContent = Object.keys(elementFrequencies).length;
            document.getElementById('filteredPrompts').textContent = getFilteredPrompts().length;
            document.getElementById('selectedElements').textContent = selectedFilters.size;
        }
        
        function populateElementFilters() {
            const container = document.getElementById('elementFilters');
            container.innerHTML = '';
            
            const sortedElements = Object.entries(elementFrequencies)
                .sort((a, b) => b[1] - a[1]);
            
            sortedElements.forEach(([element, count]) => {
                const filterDiv = document.createElement('div');
                filterDiv.className = 'element-filter';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `filter-${element}`;
                checkbox.value = element;
                checkbox.onchange = () => toggleFilter(element);
                
                const label = document.createElement('label');
                label.htmlFor = `filter-${element}`;
                label.textContent = `${element} (${count})`;
                label.style.cursor = 'pointer';
                
                filterDiv.appendChild(checkbox);
                filterDiv.appendChild(label);
                container.appendChild(filterDiv);
            });
        }
        
        function toggleFilter(element) {
            if (selectedFilters.has(element)) {
                selectedFilters.delete(element);
            } else {
                selectedFilters.add(element);
            }
            updateFilteredView();
            
            // Update checkbox state
            const checkbox = document.getElementById(`filter-${element}`);
            if (checkbox) {
                checkbox.checked = selectedFilters.has(element);
            }
        }
        
        function getFilteredPrompts() {
            const searchTerm = document.getElementById('searchBox').value.toLowerCase();
            
            return promptData.filter(prompt => {
                // Search filter
                if (searchTerm && !prompt['Unique ID'].toString().includes(searchTerm)) {
                    return false;
                }
                
                // Element filters
                if (selectedFilters.size > 0) {
                    const promptCodes = prompt['List of all codes in prompt'] ? 
                        smartSplitCodes(prompt['List of all codes in prompt']) : [];
                    
                    // Check if prompt has ALL selected filters
                    for (let filter of selectedFilters) {
                        if (!promptCodes.includes(filter)) {
                            return false;
                        }
                    }
                }
                
                return true;
            });
        }
        
        function updateFilteredView() {
            updateStats();
            populatePromptList();
            updateFrequencyChart();
        }
        
        function populatePromptList() {
            const container = document.getElementById('promptItems');
            container.innerHTML = '';
            
            const filteredPrompts = getFilteredPrompts();
            
            filteredPrompts.forEach(prompt => {
                const item = document.createElement('div');
                item.className = 'prompt-item';
                if (prompt['Unique ID'] === selectedPromptId) {
                    item.classList.add('selected');
                }
                item.textContent = `ID: ${prompt['Unique ID']}`;
                item.onclick = () => selectPrompt(prompt['Unique ID']);
                container.appendChild(item);
            });
        }
        
        function selectPrompt(id) {
            selectedPromptId = id;
            const prompt = promptData.find(p => p['Unique ID'] === id);
            
            if (prompt) {
                displayPromptDetails(prompt);
                populatePromptList(); // Update to show selection
                updateNetworkHighlight(); // Highlight network elements
            }
        }
        
        function displayPromptDetails(prompt) {
            const container = document.getElementById('promptDetails');
            
            const structures = prompt['Elements and their Structure'] ? 
                prompt['Elements and their Structure'].split(';').map(s => s.trim()) : [];
            
            const codes = prompt['List of all codes in prompt'] ? 
                smartSplitCodes(prompt['List of all codes in prompt']).filter(c => c && !c.includes(':')) : [];
            
            container.innerHTML = `
                <div class="prompt-details">
                    <h2>Prompt Details - ID: ${prompt['Unique ID']}</h2>
                    
                    <div class="detail-section">
                        <h3>Elements and their Structure</h3>
                        <div class="structure-list">
                            ${structures.map(structure => `
                                <div class="structure-item">${structure}</div>
                            `).join('')}
                        </div>
                    </div>
                    
                    <div class="detail-section">
                        <h3>Description of Element Interactions & Evidence</h3>
                        <div class="description-text">${prompt['Description of Interaction (with prompt examples)'] || 'No description available.'}</div>
                    </div>
                    
                    <div class="detail-section">
                        <h3>Identified Elements</h3>
                        <div class="element-tags">
                            ${codes.map(code => `
                                <span class="element-tag" onclick="toggleFilter('${code.replace(/'/g, "\\'")}')">${code}</span>
                            `).join('')}
                        </div>
                    </div>
                </div>
            `;
        }
        
        function createFrequencyChart() {
            const ctx = document.getElementById('frequencyChart').getContext('2d');
            
            const sortedElements = Object.entries(elementFrequencies)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 20); // Top 20 elements
            
            const gradient = ctx.createLinearGradient(0, 0, 800, 0);
            gradient.addColorStop(0, '#667eea');
            gradient.addColorStop(1, '#764ba2');
            
            frequencyChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: sortedElements.map(([element]) => element),
                    datasets: [{
                        label: 'Frequency',
                        data: sortedElements.map(([, count]) => count),
                        backgroundColor: gradient,
                        borderWidth: 0
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const index = elements[0].index;
                            const element = sortedElements[index][0];
                            toggleFilter(element);
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `${context.parsed.x} prompts include this element`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            beginAtZero: true,
                            grid: {
                                display: false
                            },
                            ticks: {
                                precision: 0
                            }
                        },
                        y: {
                            grid: {
                                display: false
                            },
                            ticks: {
                                font: {
                                    size: 11
                                }
                            }
                        }
                    }
                }
            });
        }
        
        function updateFrequencyChart() {
            if (!frequencyChart) return;
            
            // Recalculate frequencies based on filtered prompts
            const filteredPrompts = getFilteredPrompts();
            const filteredFrequencies = {};
            
            filteredPrompts.forEach(prompt => {
                if (prompt['List of all codes in prompt']) {
                    const codes = smartSplitCodes(prompt['List of all codes in prompt']);
                    codes.forEach(code => {
                        if (code && !code.includes(':')) {
                            filteredFrequencies[code] = (filteredFrequencies[code] || 0) + 1;
                        }
                    });
                }
            });
            
            const sortedElements = Object.entries(filteredFrequencies)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 20);
            
            frequencyChart.data.labels = sortedElements.map(([element]) => element);
            frequencyChart.data.datasets[0].data = sortedElements.map(([, count]) => count);
            frequencyChart.update();
        }
        
        function resetFilters() {
            selectedFilters.clear();
            selectedPromptId = null;
            document.getElementById('searchBox').value = '';
            
            // Uncheck all checkboxes
            document.querySelectorAll('.element-filter input[type="checkbox"]').forEach(checkbox => {
                checkbox.checked = false;
            });
            
            // Reset prompt details
            document.getElementById('promptDetails').innerHTML = `
                <div class="no-selection">
                    <h3>No Prompt Selected</h3>
                    <p>Please select a prompt from the list above to view its detailed analysis.</p>
                </div>
            `;
            
            updateFilteredView();
            resetNetworkHighlight();
        }
        
        // Search functionality
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('searchBox').addEventListener('input', updateFilteredView);
            loadData();
        });
    </script>
</body>
</html>